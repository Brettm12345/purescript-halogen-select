{
    "docs": [
        {
            "location": "/",
            "text": "Welcome\n\n\nSelect\n helps you build selection user interfaces in PureScript with Halogen. You can use it to build dropdowns, typeaheads and autocompletes, date pickers, image pickers, and more, with features like keyboard navigation, accessibility, and state management handled for you. This library takes a unique approach to component design to ensure you can leverage its features without compromising your design in any way.\n\n\nInstallation\n\n\nYou can use \nSelect\n in your PureScript project with a compatible package manager. The PureScript community typically leverages \npsc-package\n or Bower:\n\n\n1\n2\n3\n4\n5\n# Using psc-package\n\n$ psc-package install halogen-select\n\n\n# Using Bower\n\n$ bower install --save purescript-halogen-select\n\n\n\n\n\n\nQuick Start\n\n\nIf this is your first time using \nSelect\n, start with the \ntutorials\n. I'd recommend starting with the simplest example where you'll learn to make a keyboard-navigable dropdown component:\n\n\n\n\nTip\n\n\nDon't want to build your own UI components? Check out the \nOcelot component library\n!\n\n\n\n\nIf this isn't your first time, you'll find value in these resources:\n\n\n\n\nThe \nhow-to\n section contains plenty of short guides for common tasks you'll perform using \nSelect\n. Consider it a grab-bag of useful strategies and examples you can refer to when developing new components.\n\n\nThe \nconcepts\n section contains more detailed explanations on the design of the library. It will help you understand how to make good design choices and make the most of the tools available to you.\n\n\nThe \nreference documentation on Pursuit\n contains the module documentation and source code. It's a useful reference to verify what functions are available to you.\n\n\nThe \nexamples folder on Github\n contains the working source code for all the components in the \ntutorials\n. If you're building a similar component, this code can help you get started.\n\n\n\n\nWhy Select?\n\n\nSelect\n provides essential behaviors for selection UI as a flexible, extensible Halogen component. But you won't find a single render function in the code. Instead, with a few helper functions, you can write your own \nState\n \n-\n \nHTML\n function however you'd like. You can:\n\n\n\n\nExtend the component's functionality by embedding new queries in the HTML\n\n\nExtend the component's data by including as much additional state from the parent as you want (which you can then use in your render function)\n\n\nLeverage the provided features for user interaction, state management, accessibility, and logic\n\n\nRetain complete freedom over the design and aesthetic of your selection component\n\n\n\n\n\n\nFor visual learners\n\n\nI gave a talk at the Los Angeles PureScript meetup in April 2018 about the approach this library takes. It provides an overview of our design approach, including advantages and drawbacks, as well as a simple walkthrough of building a dropdown. No, the man in the preview isn't me -- that's \nPhil Freeman\n, the designer of the PureScript programming language.",
            "title": "Home"
        },
        {
            "location": "/#welcome",
            "text": "Select  helps you build selection user interfaces in PureScript with Halogen. You can use it to build dropdowns, typeaheads and autocompletes, date pickers, image pickers, and more, with features like keyboard navigation, accessibility, and state management handled for you. This library takes a unique approach to component design to ensure you can leverage its features without compromising your design in any way.",
            "title": "Welcome"
        },
        {
            "location": "/#installation",
            "text": "You can use  Select  in your PureScript project with a compatible package manager. The PureScript community typically leverages  psc-package  or Bower:  1\n2\n3\n4\n5 # Using psc-package \n$ psc-package install halogen-select # Using Bower \n$ bower install --save purescript-halogen-select",
            "title": "Installation"
        },
        {
            "location": "/#quick-start",
            "text": "If this is your first time using  Select , start with the  tutorials . I'd recommend starting with the simplest example where you'll learn to make a keyboard-navigable dropdown component:   Tip  Don't want to build your own UI components? Check out the  Ocelot component library !   If this isn't your first time, you'll find value in these resources:   The  how-to  section contains plenty of short guides for common tasks you'll perform using  Select . Consider it a grab-bag of useful strategies and examples you can refer to when developing new components.  The  concepts  section contains more detailed explanations on the design of the library. It will help you understand how to make good design choices and make the most of the tools available to you.  The  reference documentation on Pursuit  contains the module documentation and source code. It's a useful reference to verify what functions are available to you.  The  examples folder on Github  contains the working source code for all the components in the  tutorials . If you're building a similar component, this code can help you get started.",
            "title": "Quick Start"
        },
        {
            "location": "/#why-select",
            "text": "Select  provides essential behaviors for selection UI as a flexible, extensible Halogen component. But you won't find a single render function in the code. Instead, with a few helper functions, you can write your own  State   -   HTML  function however you'd like. You can:   Extend the component's functionality by embedding new queries in the HTML  Extend the component's data by including as much additional state from the parent as you want (which you can then use in your render function)  Leverage the provided features for user interaction, state management, accessibility, and logic  Retain complete freedom over the design and aesthetic of your selection component    For visual learners  I gave a talk at the Los Angeles PureScript meetup in April 2018 about the approach this library takes. It provides an overview of our design approach, including advantages and drawbacks, as well as a simple walkthrough of building a dropdown. No, the man in the preview isn't me -- that's  Phil Freeman , the designer of the PureScript programming language.",
            "title": "Why Select?"
        },
        {
            "location": "/tutorials/getting-started/",
            "text": "Introduction\n\n\nHalogen is a powerful framework for building PureScript applications. It\u2019s used by several companies, including SlamData and my own company, CitizenNet (a Cond\u00e9 Nast company), among others. The \nSelect\n library is written for the Halogen framework, so if you don\u2019t know how to use Halogen yet, you ought to start with the \nHalogen guide\n. That said, with only passing familiarity with Halogen, you should be able to follow along just fine!\n\n\nSetup\n\n\nInstead of creating a new Halogen project from scratch, we\u2019ll start with a minimal starter template. This template includes the HTML, build scripts, and basic \nMain.purs\n file necessary to run your Halogen application. It also includes a component with the bare minimum definitions in place. This component does nothing at all, which is nice because we can easily use it to start building dropdowns, typeaheads, and other components.\n\n\n\n\nInfo\n\n\nWe prefer Yarn over NPM for package management and scripts, but either one will work. Anywhere you see \nyarn \nscript\n, you can substitute \nnpm run \nscript\n instead. Feel free to look at the \npackage.json\n file if you want to see what these scripts are doing.\n\n\n\n\nInstallation\n\n\nFirst, clone the Halogen template project from CitizenNet, install dependencies, and make sure things build properly. If they don\u2019t, please reach out on the \nPurescript user forum\n so we can fix it!\n\n\nNext, make sure to install \nSelect\n:\n\n\n1\nbower i --save purescript-halogen-select\n\n\n\n\n\n\nAnd that's it! You now have everything you need to complete the tutorials. This is the full set of steps you can follow to get all set up:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n# Get the CitizenNet starter Halogen project\n\ngit clone git@github.com:citizennet/purescript-halogen-template.git\n\n\n# Change into the directory and install packages\n\n\ncd\n purescript-halogen-template \n yarn\n\n\n# Install a new package: purescript-halogen-select\n\nbower i --save purescript-halogen-select\n\n\n# Build the project\n\nyarn build\n\n\n# Open the application in the browser\n\nopen dist/index.html\n\n\n\n\n\n\nAfter you complete each step in the tutorial, make sure to rebuild the project and refresh your browser to see your updated component.\n\n\nHelpful tip: Watching for file changes\n\n\nIt\u2019s convenient to keep a terminal running which watches for file changes, rebuilds the project, and bundles JavaScript on your behalf. Then, when you make a change to a file, all you have to do is wait a moment and refresh the page to see your updates.\n\n\nWhen I write PureScript, I usually work with two terminals open. I use the first to write code, and the second to watch those changes and rebuild. I recommend using the same technique as you walk through these tutorials. These three steps are all you need:\n\n\n\n\nOpen a new terminal and run the \nwatch\n script\n\n\nOpen your editor to a source file\n\n\nOpen a new tab in your browser pointed to \ndist/index.html\n so you can see the app\n\n\n\n\nTo test everything is working, try editing \nsrc/Component.purs\n to change the title of the page. The project should automatically rebuild on save. Then, when you refresh the browser, you should see your new text rendered.\n\n\n1\n2\n# Watch for changes and rebuild (remember to refresh the page after builds)\n\nyarn watch\n\n\n\n\n\n\nA whirlwind tour of our starter component\n\n\nThe project starts off with a minimal Halogen component. As a brief refresher, I'll step through each of the types and functions involved.\n\n\n\n\nInfo\n\n\nIf you are already quite familiar with Halogen, feel free to skip this section entirely.\n\n\n\n\nQuery Algebra\n\n\nHow does a component know what to do?\n\n\nIn Halogen, we give names to each computation we'd like a component to run. Computations that can have side effects but don't return anything are colloquially called \nactions\n; those that can have side effects and also return something are called \nrequests\n. The type that lists out the possible actions and requests for a component is called the component's \nquery algebra\n. The Halogen guide has a relevant \nsection about query algebras\n if you'd like to know more.\n\n\nWhat actions and requests can our starter component perform? By looking at the query algebra, we see just one constructor:\n\n\n1\n2\ndata\n \nQuery\n \na\n\n  \n=\n \nNoOp\n \na\n\n\n\n\n\n\n\nAll we know so far is that this component can do one thing: evaluate a query called \nNoOp\n. We'll see what it does later on when we look at the \neval\n function.\n\n\nState\n\n\nEvery component encapsulates some state, described by its \nState\n type. You will usually see Halogen components use records to hold state, like this:\n\n\n1\ntype\n \nState\n \n=\n \n{\n \non\n \n::\n \nBoolean\n,\n \nname\n \n::\n \nString\n \n}\n\n\n\n\n\n\n\nState is the core of your component. Most of the queries you see in Halogen components modify state in some way, and the render function that produces HTML for the component has only the \nState\n type as its argument.\n\n\nFor our starter component, we don't need any state just yet, so we've simply assigned it the \nUnit\n type. When we start building selection components, however, we'll soon create a record to hold our state.\n\n\n1\ntype\n \nState\n \n=\n \nUnit\n\n\n\n\n\n\n\nInput\n\n\nA component's \nInput\n type can be thought of as a container for any information you'd like to pass to the component. It's most commonly used to provide a component with some initial \nState\n values via the \ninitialState\n \n::\n \nInput\n \n-\n \nState\n function. However, it's more powerful than that!\n\n\nOnce a Halogen component has been mounted to the DOM, there is only one way to continue sending it new information: its \nInput\n type paired with its \nreceiver\n function. Every time the parent component re-renders, it will send a new \nInput\n to the child component.\n\n\nFor more information on the \nInput\n type, see the \nParent and Child Components\n section of the Halogen guide.\n\n\nOur starter component doesn't need any input, so we'll assign it the \nUnit\n type. However, once we build a dropdown or typeahead, we'll probably want to receive the list of items that can be selected as input.\n\n\n1\ntype\n \nInput\n \n=\n \nUnit\n\n\n\n\n\n\n\nMessage\n\n\nHow does a component tell its parent when something important has happened? In Halogen, this is accomplished with a \nMessage\n type. Like the query algebra, this is just a type describing messages that can be raised, containing some information. To actually trigger sending a particular message, you can use the \nraise\n function provided by Halogen.\n\n\nWhen we start building selection components, we'll use messages to notify parent components when items have been selected or removed. Our starter component doesn't need to raise any messages, however, so we've given it the \nVoid\n type.\n\n\nWhy are we using \nVoid\n when we have no messages?\nWhy use \nVoid\n instead of \nUnit\n for the \nMessage\n type when it has no constructors? This is common practice in Halogen because of how messages are used by parent components. When your component raises a message, it gets handled by the parent using a function like this:\nChild\n.\nMessage\n \n-\n \nMaybe\n \n(\nParentQuery\n \nUnit\n)\nIf you want to ignore all messages from the child, you could write an implementation like this:\nHalogen\n.\nHTML\n.\nEvents\n.\ninput\n \n \nconst\n \nNothing\nHowever, if the child's message type is \nVoid\n, then you can use the \nabsurd\n function from \nData.Void\n:\nabsurd\n \n::\n \nVoid\n \n-\n \na\nThis saves you a bit of typing when you mount a child component in a slot and makes it absolutely unambiguous that there are no messages to handle. It also ensures that if you add a message to the child component later on you'll get a compiler error -- this is a good thing!\nCompare mounting a child component that uses \nUnit\n to represent \"no messages\" vs. using \nVoid\n:\n1\n2\n3\n4\n5\n6\n7\n-- It\ns unclear whether you\nre ignoring all messages or whether there are\n\n\n-- simply no messages to handle.\n\n\nHH\n.\nslot\n \nComponentSlot\n \ncomponent\n \nunit\n \n(\nHalogen\n.\nHTML\n.\nEvents\n.\ninput\n \n \nconst\n \nNothing\n)\n\n\n\n-- It\ns obvious there are no messages, and if that changes (the component adds a\n\n\n-- message) you\nll get a nice compile-time error.\n\n\nHH\n.\nslot\n \nComponentSlot\n \ncomponent\n \nunit\n \nabsurd\n\n\n\n\n\n\nFor more information on messages, see the \nParent and Child Components\n section in the Halogen guide.\n\n\n1\ntype\n \nMessage\n \n=\n \nVoid\n\n\n\n\n\n\n\nChildQuery and ChildSlot\n\n\nHalogen components often have further child components. To maintain type safety when managing multiple child components, Halogen uses a pair of concepts: \nchild queries\n and \nchild slots\n.\n\n\n\n\n\n\nThe \nChildQuery\n type lists out each unique type of child component your component has. For each type of child component, you'll add its query type here.\n\n\n\n\n\n\nThe \nChildSlot\n type works like an address book for the various child components. If you only have one child component of any distinct \nChildQuery\n, then you can just use \nunit\n. However, if you have multiple children with the same query type, you need some way to distinguish between them. It's common to use custom types or integers for this.\n\n\n\n\n\n\nSee the \nMultiple Types of Child Component\n section of the Halogen guide for more details.\n\n\nFor now, our component has no children. Once we bring in the \nSelect\n component we'll update these types.\n\n\n1\n2\ntype\n \nChildQuery\n \n=\n \nConst\n \nVoid\n\n\ntype\n \nChildSlot\n \n=\n \nUnit\n\n\n\n\n\n\n\nComponent\n\n\nAh! We can finally create our component. The actual component definition is simple: we call the \nparentComponent\n function from Halogen to assert we're creating a component that can have further child components and provide it with the four functions it needs to operate. More on those in a moment!\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\ncomponent\n \n::\n \n\u2200\n \neff\n \nm\n\n  \n.\n \nMonadAff\n \neff\n \nm\n\n \n=\n \nH\n.\nComponent\n \nHH\n.\nHTML\n \nQuery\n \nInput\n \nMessage\n \nm\n\n\ncomponent\n \n=\n\n  \nH\n.\nparentComponent\n\n    \n{\n \ninitialState\n\n    \n,\n \nrender\n\n    \n,\n \neval\n\n    \n,\n \nreceiver\n:\n \nconst\n \nNothing\n\n    \n}\n\n\n  \nwhere\n\n\n\n\n\n\n\nNext, lets look at those function definitions, defined in the \nwhere\n clause:\n\n\ninitialState\n\n\nThe \ninitialState\n function describes how to go from the component's \nInput\n type to its \nState\n type. In this case, our \nState\n type is just \nUnit\n, so we'll throw away the input and return \nunit\n.\n\n\n1\n2\n3\n4\n5\ninitialState\n \n::\n \nInput\n \n-\n \nState\n\n\ninitialState\n \n=\n \nconst\n \nunit\n\n\n\n-- Could also be written this way:\n\n\ninitialState\n \n=\n \nid\n\n\n\n\n\n\n\nrender\n\n\nThe \nrender\n function describes how to go from the component's \nState\n type to some HTML, where that HTML can include any of the components listed in the \nChildQuery\n type. You'll use plenty of code from these modules when writing render functions:\n\n\n1\n2\n3\nimport\n \nHalogen.HTML\n \nas\n \nHH\n\n\nimport\n \nHalogen.HTML.Events\n \nas\n \nHE\n\n\nimport\n \nHalogen.HTML.Properties\n \nas\n \nHP\n\n\n\n\n\n\n\nWe're going to spend a lot of time writing render functions in the following tutorials. You can refer to the Halogen guide's \nsection on rendering\n for more information.\n\n\nFor now we won't render anything to the page, represented by an empty div.\n\n\n1\n2\nrender\n \n::\n \nState\n \n-\n \nH\n.\nParentHTML\n \nQuery\n \nChildQuery\n \nChildSlot\n \nm\n\n\nrender\n \nst\n \n=\n \nHH\n.\ndiv_\n \n[]\n\n\n\n\n\n\n\neval\n\n\nThe \neval\n function describes what to do when one of the queries from the component's query algebra is called. There are various ways a query can be triggered:\n\n\n\n\nThe parent component can trigger a child component query using the \nquery\n function\n\n\nA user can trigger a query with an event in HTML, like \nonClick\n\n\nThe \neval\n function can recursively call itself while evaluating a query\n\n\n\n\nThe \neval\n function is where you get to actually define what all your queries \ndo\n. Unlike the render function, you can actually perform all kinds of side effects here, like make API calls, update state, trigger queries in child components, raise messages, and more.\n\n\nAs usual, our starter component won't do much in its \neval\n. When it receives the \nNoOp\n constructor, it will do nothing and return the contents of the query, which in this case will always be \nunit\n.\n\n\n1\n2\n3\neval\n \n::\n \nQuery\n \n~\n \nH\n.\nParentDSL\n \nState\n \nQuery\n \nChildQuery\n \nChildSlot\n \nMessage\n \nm\n\n\neval\n \n=\n \ncase\n \n_\n \nof\n\n  \nNoOp\n \nnext\n \n-\n \npure\n \nnext\n\n\n\n\n\n\n\nreceiver\n\n\nThe \nreceiver\n function describes what to do when a parent component sends in new \nInput\n. Its type signature looks like this:\n\n\n1\nreceiver\n \n::\n \nInput\n \n-\n \nMaybe\n \n(\nQuery\n \nUnit\n)\n\n\n\n\n\n\n\nOnce a Halogen component has been mounted, the only way to send it new input is via its \nreceiver\n function. When its parent re-renders, it will automatically send the child component's input type again, and it's up to the \nreceiver\n function to decide what to do with it.\n\n\nThis function can either provide a query to call, or \nNothing\n if you'd like to ignore new input. If you elect to provide a query then you unlock all the power available in the \neval\n function and can describe all sorts of things to do on new input, like making API calls or updating state.\n\n\nIn our case, we don't care about new input, so we'll ignore the input and return \nNothing\n.\n\n\n1\n2\n3\n{\n \n...\n\n\n,\n \nreceiver\n:\n \nconst\n \nNothing\n\n\n}",
            "title": "Project setup"
        },
        {
            "location": "/tutorials/getting-started/#introduction",
            "text": "Halogen is a powerful framework for building PureScript applications. It\u2019s used by several companies, including SlamData and my own company, CitizenNet (a Cond\u00e9 Nast company), among others. The  Select  library is written for the Halogen framework, so if you don\u2019t know how to use Halogen yet, you ought to start with the  Halogen guide . That said, with only passing familiarity with Halogen, you should be able to follow along just fine!",
            "title": "Introduction"
        },
        {
            "location": "/tutorials/getting-started/#setup",
            "text": "Instead of creating a new Halogen project from scratch, we\u2019ll start with a minimal starter template. This template includes the HTML, build scripts, and basic  Main.purs  file necessary to run your Halogen application. It also includes a component with the bare minimum definitions in place. This component does nothing at all, which is nice because we can easily use it to start building dropdowns, typeaheads, and other components.   Info  We prefer Yarn over NPM for package management and scripts, but either one will work. Anywhere you see  yarn  script , you can substitute  npm run  script  instead. Feel free to look at the  package.json  file if you want to see what these scripts are doing.",
            "title": "Setup"
        },
        {
            "location": "/tutorials/getting-started/#installation",
            "text": "First, clone the Halogen template project from CitizenNet, install dependencies, and make sure things build properly. If they don\u2019t, please reach out on the  Purescript user forum  so we can fix it!  Next, make sure to install  Select :  1 bower i --save purescript-halogen-select   And that's it! You now have everything you need to complete the tutorials. This is the full set of steps you can follow to get all set up:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 # Get the CitizenNet starter Halogen project \ngit clone git@github.com:citizennet/purescript-halogen-template.git # Change into the directory and install packages  cd  purescript-halogen-template   yarn # Install a new package: purescript-halogen-select \nbower i --save purescript-halogen-select # Build the project \nyarn build # Open the application in the browser \nopen dist/index.html   After you complete each step in the tutorial, make sure to rebuild the project and refresh your browser to see your updated component.",
            "title": "Installation"
        },
        {
            "location": "/tutorials/getting-started/#helpful-tip-watching-for-file-changes",
            "text": "It\u2019s convenient to keep a terminal running which watches for file changes, rebuilds the project, and bundles JavaScript on your behalf. Then, when you make a change to a file, all you have to do is wait a moment and refresh the page to see your updates.  When I write PureScript, I usually work with two terminals open. I use the first to write code, and the second to watch those changes and rebuild. I recommend using the same technique as you walk through these tutorials. These three steps are all you need:   Open a new terminal and run the  watch  script  Open your editor to a source file  Open a new tab in your browser pointed to  dist/index.html  so you can see the app   To test everything is working, try editing  src/Component.purs  to change the title of the page. The project should automatically rebuild on save. Then, when you refresh the browser, you should see your new text rendered.  1\n2 # Watch for changes and rebuild (remember to refresh the page after builds) \nyarn watch",
            "title": "Helpful tip: Watching for file changes"
        },
        {
            "location": "/tutorials/getting-started/#a-whirlwind-tour-of-our-starter-component",
            "text": "The project starts off with a minimal Halogen component. As a brief refresher, I'll step through each of the types and functions involved.   Info  If you are already quite familiar with Halogen, feel free to skip this section entirely.",
            "title": "A whirlwind tour of our starter component"
        },
        {
            "location": "/tutorials/getting-started/#query-algebra",
            "text": "How does a component know what to do?  In Halogen, we give names to each computation we'd like a component to run. Computations that can have side effects but don't return anything are colloquially called  actions ; those that can have side effects and also return something are called  requests . The type that lists out the possible actions and requests for a component is called the component's  query algebra . The Halogen guide has a relevant  section about query algebras  if you'd like to know more.  What actions and requests can our starter component perform? By looking at the query algebra, we see just one constructor:  1\n2 data   Query   a \n   =   NoOp   a    All we know so far is that this component can do one thing: evaluate a query called  NoOp . We'll see what it does later on when we look at the  eval  function.",
            "title": "Query Algebra"
        },
        {
            "location": "/tutorials/getting-started/#state",
            "text": "Every component encapsulates some state, described by its  State  type. You will usually see Halogen components use records to hold state, like this:  1 type   State   =   {   on   ::   Boolean ,   name   ::   String   }    State is the core of your component. Most of the queries you see in Halogen components modify state in some way, and the render function that produces HTML for the component has only the  State  type as its argument.  For our starter component, we don't need any state just yet, so we've simply assigned it the  Unit  type. When we start building selection components, however, we'll soon create a record to hold our state.  1 type   State   =   Unit",
            "title": "State"
        },
        {
            "location": "/tutorials/getting-started/#input",
            "text": "A component's  Input  type can be thought of as a container for any information you'd like to pass to the component. It's most commonly used to provide a component with some initial  State  values via the  initialState   ::   Input   -   State  function. However, it's more powerful than that!  Once a Halogen component has been mounted to the DOM, there is only one way to continue sending it new information: its  Input  type paired with its  receiver  function. Every time the parent component re-renders, it will send a new  Input  to the child component.  For more information on the  Input  type, see the  Parent and Child Components  section of the Halogen guide.  Our starter component doesn't need any input, so we'll assign it the  Unit  type. However, once we build a dropdown or typeahead, we'll probably want to receive the list of items that can be selected as input.  1 type   Input   =   Unit",
            "title": "Input"
        },
        {
            "location": "/tutorials/getting-started/#message",
            "text": "How does a component tell its parent when something important has happened? In Halogen, this is accomplished with a  Message  type. Like the query algebra, this is just a type describing messages that can be raised, containing some information. To actually trigger sending a particular message, you can use the  raise  function provided by Halogen.  When we start building selection components, we'll use messages to notify parent components when items have been selected or removed. Our starter component doesn't need to raise any messages, however, so we've given it the  Void  type.  Why are we using  Void  when we have no messages? Why use  Void  instead of  Unit  for the  Message  type when it has no constructors? This is common practice in Halogen because of how messages are used by parent components. When your component raises a message, it gets handled by the parent using a function like this: Child . Message   -   Maybe   ( ParentQuery   Unit ) If you want to ignore all messages from the child, you could write an implementation like this: Halogen . HTML . Events . input     const   Nothing However, if the child's message type is  Void , then you can use the  absurd  function from  Data.Void : absurd   ::   Void   -   a This saves you a bit of typing when you mount a child component in a slot and makes it absolutely unambiguous that there are no messages to handle. It also ensures that if you add a message to the child component later on you'll get a compiler error -- this is a good thing! Compare mounting a child component that uses  Unit  to represent \"no messages\" vs. using  Void : 1\n2\n3\n4\n5\n6\n7 -- It s unclear whether you re ignoring all messages or whether there are  -- simply no messages to handle.  HH . slot   ComponentSlot   component   unit   ( Halogen . HTML . Events . input     const   Nothing )  -- It s obvious there are no messages, and if that changes (the component adds a  -- message) you ll get a nice compile-time error.  HH . slot   ComponentSlot   component   unit   absurd    For more information on messages, see the  Parent and Child Components  section in the Halogen guide.  1 type   Message   =   Void",
            "title": "Message"
        },
        {
            "location": "/tutorials/getting-started/#childquery-and-childslot",
            "text": "Halogen components often have further child components. To maintain type safety when managing multiple child components, Halogen uses a pair of concepts:  child queries  and  child slots .    The  ChildQuery  type lists out each unique type of child component your component has. For each type of child component, you'll add its query type here.    The  ChildSlot  type works like an address book for the various child components. If you only have one child component of any distinct  ChildQuery , then you can just use  unit . However, if you have multiple children with the same query type, you need some way to distinguish between them. It's common to use custom types or integers for this.    See the  Multiple Types of Child Component  section of the Halogen guide for more details.  For now, our component has no children. Once we bring in the  Select  component we'll update these types.  1\n2 type   ChildQuery   =   Const   Void  type   ChildSlot   =   Unit",
            "title": "ChildQuery and ChildSlot"
        },
        {
            "location": "/tutorials/getting-started/#component",
            "text": "Ah! We can finally create our component. The actual component definition is simple: we call the  parentComponent  function from Halogen to assert we're creating a component that can have further child components and provide it with the four functions it needs to operate. More on those in a moment!   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 component   ::   \u2200   eff   m \n   .   MonadAff   eff   m \n  =   H . Component   HH . HTML   Query   Input   Message   m  component   = \n   H . parentComponent \n     {   initialState \n     ,   render \n     ,   eval \n     ,   receiver :   const   Nothing \n     } \n\n   where    Next, lets look at those function definitions, defined in the  where  clause:",
            "title": "Component"
        },
        {
            "location": "/tutorials/getting-started/#initialstate",
            "text": "The  initialState  function describes how to go from the component's  Input  type to its  State  type. In this case, our  State  type is just  Unit , so we'll throw away the input and return  unit .  1\n2\n3\n4\n5 initialState   ::   Input   -   State  initialState   =   const   unit  -- Could also be written this way:  initialState   =   id",
            "title": "initialState"
        },
        {
            "location": "/tutorials/getting-started/#render",
            "text": "The  render  function describes how to go from the component's  State  type to some HTML, where that HTML can include any of the components listed in the  ChildQuery  type. You'll use plenty of code from these modules when writing render functions:  1\n2\n3 import   Halogen.HTML   as   HH  import   Halogen.HTML.Events   as   HE  import   Halogen.HTML.Properties   as   HP    We're going to spend a lot of time writing render functions in the following tutorials. You can refer to the Halogen guide's  section on rendering  for more information.  For now we won't render anything to the page, represented by an empty div.  1\n2 render   ::   State   -   H . ParentHTML   Query   ChildQuery   ChildSlot   m  render   st   =   HH . div_   []",
            "title": "render"
        },
        {
            "location": "/tutorials/getting-started/#eval",
            "text": "The  eval  function describes what to do when one of the queries from the component's query algebra is called. There are various ways a query can be triggered:   The parent component can trigger a child component query using the  query  function  A user can trigger a query with an event in HTML, like  onClick  The  eval  function can recursively call itself while evaluating a query   The  eval  function is where you get to actually define what all your queries  do . Unlike the render function, you can actually perform all kinds of side effects here, like make API calls, update state, trigger queries in child components, raise messages, and more.  As usual, our starter component won't do much in its  eval . When it receives the  NoOp  constructor, it will do nothing and return the contents of the query, which in this case will always be  unit .  1\n2\n3 eval   ::   Query   ~   H . ParentDSL   State   Query   ChildQuery   ChildSlot   Message   m  eval   =   case   _   of \n   NoOp   next   -   pure   next",
            "title": "eval"
        },
        {
            "location": "/tutorials/getting-started/#receiver",
            "text": "The  receiver  function describes what to do when a parent component sends in new  Input . Its type signature looks like this:  1 receiver   ::   Input   -   Maybe   ( Query   Unit )    Once a Halogen component has been mounted, the only way to send it new input is via its  receiver  function. When its parent re-renders, it will automatically send the child component's input type again, and it's up to the  receiver  function to decide what to do with it.  This function can either provide a query to call, or  Nothing  if you'd like to ignore new input. If you elect to provide a query then you unlock all the power available in the  eval  function and can describe all sorts of things to do on new input, like making API calls or updating state.  In our case, we don't care about new input, so we'll ignore the input and return  Nothing .  1\n2\n3 {   ...  ,   receiver :   const   Nothing  }",
            "title": "receiver"
        },
        {
            "location": "/tutorials/dropdown/",
            "text": "Let's Build a Dropdown in PureScript!\n\n\nDropdowns are among the simplest selection components you will build, but they can be tricky to get right. For example, you'll likely want to ensure that your users can type to highlight close text matches (like when you type \"Ca\" to highlight \"California\" in a state dropdown). You'll want to be accessible to folks using screen readers or keyboard-only navigation, too. And, of course, you'll want to achieve all this without compromising on your design.\n\n\nThis tutorial is intended as a beginner-friendly, thorough introduction to \nSelect\n. We'll build a functional dropdown complete with keyboard navigation. Along the way, we'll learn more about how to work with Halogen components, diagnose type errors, and other common PureScript tasks.\n\n\n\n\nInfo\n\n\nThis tutorial assumes you've followed the steps in the \nProject Setup\n section. While not necessary, this code is tested with those steps in mind.\n\n\nIt also assumes familiarity with the Halogen framework. If you need a refresher, try the official \nHalogen guide\n or the \nwhirlwind tour\n of our starter component.\n\n\n\n\nIf you are already an intermediate or advanced PureScript developer, then this tutorial will read slowly for you. Feel free to skim, get the gist of how the library works, and then move on to the \nfaster-paced and more advanced typeahead tutorial\n.\n\n\n\n\nYour code should work at the end of every step. If you run into issues or your code doesn't compile, please come visit us on the \nPureScript user forum\n or the \n#fpchat Slack channel\n.\n\n\n\n\nWe're going to build a dropdown that is functionally equivalent this one:\n\n\n\n\n\nOur component will look a little bit worse, because we're not going to spend time on CSS.\n\n\nBasic Setup\n\n\nLet's get something on the screen!\n\n\nThe simplest sort of dropdown has a button that can toggle a menu open or closed, a list of items that can be selected from that menu, and zero, one, or more selected items. For our dropdown we'll assume that you can select at most one item, and that selecting an item will replace the text on the button with that item.\n\n\nRendering a button and items\n\n\nWe'll start by rendering the button and the items. At this point our render function contains only an empty div, so let's fill in the rest of the HTML we need:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\nrender\n \n::\n \nState\n \n-\n \nH\n.\nParentHTML\n \nQuery\n \nChildQuery\n \nChildSlot\n \nm\n\n\nrender\n \nst\n \n=\n\n  \nHH\n.\ndiv_\n\n  \n[\n \nHH\n.\nh1_\n\n    \n[\n \nHH\n.\ntext\n \nDropdown\n \n]\n\n  \n,\n \nHH\n.\nbutton_\n\n    \n[\n \nHH\n.\ntext\n \nClick me to view some items\n \n]\n\n  \n,\n \nHH\n.\nul_\n\n    \n[\n \nHH\n.\nli_\n\n      \n[\n \nHH\n.\ntext\n \nItem 1\n \n]\n\n    \n,\n \nHH\n.\nli_\n\n      \n[\n \nHH\n.\ntext\n \nItem 2\n \n]\n\n    \n]\n\n  \n]\n\n\n\n\n\n\n\n\n\nMake sure to compile this code and view the new output! You should see a header, a button, and two items in the list. After each step, make sure your code still compiles.\n\n\n\n\nA better \nState\n type\n\n\nIt's already clear we're going to need more than \nUnit\n for our \nState\n type. We at least need to know three things:\n\n\n\n\nIf the menu is toggled on or off\n\n\nThe currently-selected item (if there is one)\n\n\nThe list of items available for selection\n\n\n\n\nWe can represent each of these with simple types in our state:\n\n\n1\n2\n3\n4\n5\ntype\n \nState\n \n=\n\n  \n{\n \nisOpen\n \n::\n \nBoolean\n\n  \n,\n \nselectedItem\n \n::\n \nMaybe\n \nString\n\n  \n,\n \navailableItems\n \n::\n \nArray\n \nString\n\n  \n}\n\n\n\n\n\n\n\nNow that our state contains these three fields, we need to update our \ninitialState\n function to produce the right type of values:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\ninitialState\n \n::\n \nInput\n \n-\n \nState\n\n\ninitialState\n \n=\n \nconst\n\n  \n{\n \nisOpen\n:\n \nfalse\n\n  \n,\n \nselectedItem\n:\n \nNothing\n\n  \n,\n \navailableItems\n:\n\n      \n[\n \nItem One\n\n      \n,\n \nItem Two\n\n      \n,\n \nItem Three\n\n      \n]\n\n  \n}\n\n\n\n\n\n\n\nFinally, lets update our render function to leverage the information now contained in \nState\n. If there's a selected item, that will be the button's text; if not, we'll fall back to a default message. If the menu is open, we'll list out the available items for selection.\n\n\nFor code clarity, we'll also break out the dropdown into its own helper function.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nimport\n \nData.Maybe\n \n(\nfromMaybe\n)\n\n\n\nrender\n \n::\n \nState\n \n-\n \nH\n.\nParentHTML\n \nQuery\n \nChildQuery\n \nChildSlot\n \nm\n\n\nrender\n \nst\n \n=\n\n  \nHH\n.\ndiv_\n\n  \n[\n \nHH\n.\nh1_\n\n    \n[\n \nHH\n.\ntext\n \nDropdown\n \n]\n\n  \n,\n \ndropdown\n \nst\n\n  \n]\n\n\n\ndropdown\n \n::\n \nState\n \n-\n \nH\n.\nParentHTML\n \nQuery\n \nChildQuery\n \nChildSlot\n \nm\n\n\ndropdown\n \n=\n\n  \nHH\n.\ndiv_\n\n  \n[\n \nHH\n.\nbutton_\n\n    \n[\n \nHH\n.\ntext\n \n$\n \nfromMaybe\n \nClick me to view some items\n \nst\n.\nselectedItem\n \n]\n\n  \n,\n \nif\n \nst\n.\nisOpen\n\n      \nthen\n \nHH\n.\nul_\n \n$\n \n(\n\\\nitem\n \n-\n \nHH\n.\nli_\n \n[\n \nHH\n.\ntext\n \nitem\n \n])\n \n$\n \nst\n.\navailableItems\n\n      \nelse\n \nHH\n.\ntext\n \n\n  \n]\n\n\n\n\n\n\n\n\n\nTip\n\n\nSince the dropdown has no behavior yet, try changing the \ninitialState\n to set \nisOpen\n to \ntrue\n to verify your items are in fact being rendered out to the page.\n\n\n\n\nIt ain't pretty, but at this point we've got all the rendering we need for a basic dropdown! The next step is to actually wire in some behavior.\n\n\nIntegrating the component\n\n\nLet's integrate the \nSelect\n component! In just a few steps, we'll turn our simple render function into a fully-functioning dropdown with keyboard navigation, toggling, debounced type-to-search, and several other features.\n\n\nOn building components with Select\n\n\nThe key idea behind the \nSelect\n library is to \nprovide behaviors, not rendering\n. The core component the library exposes doesn't have a render function at all! Of course, all Halogen components require a render function to work, and \nSelect\n is no different. \nYou\n are expected to provide that render function.\n\n\nWhy?\n\n\nWhen you write the render function, not the library, you get to decide exactly what your component will look and feel like. You can also control what queries to trigger from HTML and when, effectively allowing you to control the behavior of the component \nwithout configuration\n. You can even extend it with new behavior and new state by using information from your parent component. The end result is a much smaller library component with a lot more flexibility and power for you.\n\n\nWe just wrote the rendering we need for an (admittedly ugly) dropdown. The render function we just wrote can actually serve almost as-is as the render function for \nSelect\n! All we have to do is mount the \nSelect\n component, make a few tweaks to our render code, and then pass in a little configuration information. Let's do that next.\n\n\nImporting the Select component\n\n\nThe first thing we'll do is bring in the \nSelect\n library in the first place.\n\n\n1\n2\nimport\n \nSelect\n \nas\n \nSelect\n\n\nimport\n \nSelect.Utils.Setters\n \nas\n \nSetters\n\n\n\n\n\n\n\n\n\nTip\n\n\nYou can always \nview the module documentation for Select on Pursuit\n or the \nsource code on GitHub\n. This is useful when integrating with third-party components so that you can check out the \nInput\n, \nState\n, \nQuery\n, and \nMessage\n types.\n\n\n\n\nNext, we need to update our \nChildSlot\n and \nChildQuery\n types. We're only going to have one dropdown so we can leave the child slot as \nUnit\n; we do need to add the \nSelect\n component's query type to our \nChildQuery\n synonym, however.\n\n\nThis code, unfortunately, won't work:\n\n\n1\n2\n3\n4\n5\n6\n7\ntype\n \nChildQuery\n \n=\n \nSelect\n.\nQuery\n\n\n\nError\n \nfound\n:\n\n  \nType\n \nsynonym\n \nSelect\n.\nQuery\n \nis\n \npartially\n \napplied\n.\n\n  \nType\n \nsynonyms\n \nmust\n \nbe\n \napplied\n \nto\n \nall\n \nof\n \ntheir\n \ntype\n \narguments\n.\n\n\n\nin\n \ntype\n \nsynonym\n \nChildQuery\n\n\n\n\n\n\n\nThe compiler has noticed that \nChildQuery\n, a type synonym, is partially applied. That's because \nSelect\n.\nQuery\n, itself a type synonym, takes several arguments as described in the \nmodule documentation on Pursuit\n. Let's walk through each one:\n\n\n1\ntype\n \nChildQuery\n \no\n \nitem\n \neff\n \n=\n \nSelect\n.\nQuery\n \no\n \nitem\n \neff\n\n\n\n\n\n\n\no\n is \nyour\n query type. Remember how you can embed your own queries into \nSelect\n, and in that way extend the component's functionality? This is how. So we can fill in the first argument:\n\n\n1\ntype\n \nChildQuery\n \nitem\n \neff\n \n=\n \nSelect\n.\nQuery\n \nQuery\n \nitem\n \neff\n\n\n\n\n\n\n\nitem\n is the type of whatever items you want to be selectable. Commonly these are strings, but can also be custom data types. Later on, in the \ntypeahead tutorial\n, we'll see how powerful custom data types can be for rendering purposes. For our simple dropdown we'll simply specialize this to \nString\n:\n\n\n1\ntype\n \nChildQuery\n \neff\n \n=\n \nSelect\n.\nQuery\n \nQuery\n \nString\n \neff\n\n\n\n\n\n\n\neff\n is the type of whatever effect rows your component leverages. \nSelect\n performs some effects, like manipulating the DOM or using threads to perform debouncing on your behalf asynchronously, and it must verify that its effects match your parent component effects. We'll leave this as an argument for now, but when we mount the component, we'll provide some concrete effects.\n\n\nWhat happens if we try to save this?\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nError\n \nfound\n \nin\n \nmodule\n \nComponent\n \n:\n\n\n  \nCould\n \nnot\n \nmatch\n \nkind\n\n    \nType\n\n\n  \nwith\n \nkind\n\n    \n#\n \nControl\n.\nMonad\n.\nEff\n.\nEffect\n\n\n\nwhile\n \nchecking\n \nthe\n \nkind\n \nof\n \nState\n \n-\n \nParentHTML\n \nQuery\n \nChildQuery\n \nChildSlot\n \nm0\n\n\n\n\n\n\n\nWhoops! Our \nrender\n and \neval\n functions expect \nChildQuery\n to have the kind \nType\n, but instead we've provided a type synonym that's still awaiting an argument of kind \n#\n \nEffect\n (read: a row of effects). We need to supply that argument. Let's update those two functions:\n\n\n1\n2\n3\nrender\n \n::\n \nState\n \n-\n \nH\n.\nParentHTML\n \nQuery\n \n(\nChildQuery\n \neff\n)\n \nChildSlot\n \nm\n\n\ndropdown\n \n::\n \nState\n \n-\n \nH\n.\nParentHTML\n \nQuery\n \n(\nChildQuery\n \neff\n)\n \nChildSlot\n \nm\n\n\neval\n \n::\n \nQuery\n \n~\n \nH\n.\nParentDSL\n \nState\n \nQuery\n \n(\nChildQuery\n \neff\n)\n \nChildSlot\n \nMessage\n \nm\n\n\n\n\n\n\n\nNow that \nSelect\n has been imported and we've updated our \nChildQuery\n and \nChildSlot\n types to support it, we can worry about what to do when we receive a message from the component.\n\n\nMounting the component\n\n\nWe're finally ready to mount the \nSelect\n component. Mounting any component in Halogen requires supplying a slot value, the component itself, the component's input, and the component's handler. We can put together all of these except for the input, which we haven't prepared yet.\n\n\nLet's stub out our render function in preparation:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nimport\n \nHalogen.HTML.Events\n \nas\n \nHE\n\n\n\nrender\n \n::\n \nState\n \n-\n \nH\n.\nParentHTML\n \nQuery\n \n(\nChildQuery\n \neff\n)\n \nChildSlot\n \nm\n\n\nrender\n \nst\n \n=\n\n  \nHH\n.\ndiv_\n\n  \n[\n \nHH\n.\nh1_\n\n    \n[\n \nHH\n.\ntext\n \nDropdown\n \n]\n\n  \n,\n \nHH\n.\nslot\n \nunit\n \nSelect\n.\ncomponent\n \n?\ninput\n \n(\nHE\n.\ninput\n \n \nconst\n \nNothing\n)\n\n  \n]\n\n\n\n\n\n\n\nRight away we get an error:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\nError\n \nin\n \nmodule\n \nComponent\n:\n\n\n  \nCould\n \nnot\n \nmatch\n \ntype\n\n    \neff7\n\n\n  \nwith\n \ntype\n\n    \n(\n \ndom\n \n::\n \nDOM\n\n    \n,\n \navar\n \n::\n \nAVAR\n\n    \n|\n \neff7\n\n    \n)\n\n\n\nwhen\n \ntrying\n \nto\n \nmatch\n \ntype\n \nQueryF\n \nQuery\n \nString\n \neff7\n\n  \nwith\n \ntype\n \nQueryF\n \nQuery\n \nString\n\n\n\n\n\n\n\nThis happened because \nSelect\n uses the \nAVAR\n and \nDOM\n effects, but we've asserted our component will work with ANY row. That's not true anymore! Our component will now work with any row that includes \nDOM\n and \nAVAR\n. It's easy enough to fix. We need to define our own effects row, extensible by \neff\n:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nimport\n \nControl.Monad.Aff.AVar\n \n(\nAVAR\n)\n\n\nimport\n \nDOM\n \n(\nDOM\n)\n\n\n\ntype\n \nEffects\n \neff\n \n=\n\n  \n(\n \ndom\n \n::\n \nDOM\n\n  \n,\n \navar\n \n::\n \nAVAR\n\n  \n|\n \neff\n\n  \n)\n\n\n\n\n\n\n\nNow we can update our various types to use our new row, verifying the effects are the same throughout the component. As a rule of thumb, anywhere a \nfunction\n uses \neff\n, wrap it in our new \nEffects\n type synonym, but don't apply the same rule to types or type synonyms. As an example, we'll update \ncomponent\n, but we won't update the \nChildQuery\n type synonym:\n\n\n1\n2\n3\n4\n5\n6\n7\ncomponent\n \n::\n \n\u2200\n \neff\n \nm\n\n  \n.\n \nMonadAff\n \n(\nEffects\n \neff\n)\n \nm\n\n \n=\n \nH\n.\nComponent\n \nHH\n.\nHTML\n \nQuery\n \nInput\n \nMessage\n \nm\n\n\n\nrender\n \n::\n \nState\n \n-\n \nH\n.\nParentHTML\n \nQuery\n \n(\nChildQuery\n \n(\nEffects\n \neff\n))\n \nChildSlot\n \nm\n\n\ndropdown\n \n::\n \nState\n \n-\n \nH\n.\nParentHTML\n \nQuery\n \n(\nChildQuery\n \n(\nEffects\n \neff\n))\n \nChildSlot\n \nm\n\n\neval\n \n::\n \nQuery\n \n~\n \nH\n.\nParentDSL\n \nState\n \nQuery\n \n(\nChildQuery\n \n(\nEffects\n \neff\n))\n \nChildSlot\n \nMessage\n \nm\n\n\n\n\n\n\n\nWith that out of the way, we can turn to filling in our component's input type. We can either look at the module documentation for \nSelect.Input\n or look at the type error that resulted from our typed hole, \n?input\n. Both will tell us that we need to provide a value of this type:\n\n\n1\n2\n3\n4\n5\n6\n7\ntype\n \nInput\n \no\n \nitem\n \neff\n \n=\n\n  \n{\n \ninputType\n     \n::\n \nInputType\n\n  \n,\n \nitems\n         \n::\n \nArray\n \nitem\n\n  \n,\n \ninitialSearch\n \n::\n \nMaybe\n \nString\n\n  \n,\n \ndebounceTime\n  \n::\n \nMaybe\n \nMilliseconds\n\n  \n,\n \nrender\n        \n::\n \nState\n \nitem\n \neff\n \n-\n \nComponentHTML\n \no\n \nitem\n \neff\n\n  \n}\n\n\n\n\n\n\n\nLet's build this up, step by step. First, we see we have to provide an \nInputType\n. This is described in the module documentation:\n\n\n1\n2\n3\n4\n5\n6\n-- | Text-driven inputs will operate like a normal search-driven selection component.\n\n\n-- | Toggle-driven inputs will capture key streams and debounce in reverse (only notify\n\n\n-- | about searches when time has expired).\n\n\ndata\n \nInputType\n\n  \n=\n \nTextInput\n\n  \n|\n \nToggle\n\n\n\n\n\n\n\nWe don't have any text input for our dropdown -- its a button -- so we'll go with the \nToggle\n constructor.\n\n\n1\n2\n3\n4\n5\nselectInput\n \n::\n \nSelect\n.\nInput\n \nQuery\n \nString\n \n(\nEffects\n \neff\n)\n\n\nselectInput\n \n=\n\n  \n{\n \ninputType\n:\n \nSelect\n.\nToggle\n\n  \n,\n \n...\n\n  \n}\n\n\n\n\n\n\n\nNext, we're expected to provide an array of items. Fortunately we already have those in our \nState\n. We can just send those items directly into the input.\n\n\n1\n2\n3\n4\nselectInput\n \n=\n\n  \n{\n \n...\n\n  \n,\n \nitems\n:\n \nst\n.\navailableItems\n\n  \n}\n\n\n\n\n\n\n\nNext, we're expected to provide an initial search. This would be more useful if we had a text input, but for our dropdown, we'll start off with no initial search.\n\n\n1\n2\n3\n4\nselectInput\n \n=\n\n  \n{\n \n...\n\n  \n,\n \ninitialSearch\n:\n \nNothing\n\n  \n}\n\n\n\n\n\n\n\nWhat about a debounce time? For toggle-driven components, this is how long to aggregate key presses before the user's typing should affect the list of items. For search-driven components, this is how long to delay before raising a message with the new search. For our dropdown, we don't care:\n\n\n1\n2\n3\n4\nselectInput\n \n=\n\n  \n{\n \n...\n\n  \n,\n \ndebounceTime\n:\n \nNothing\n\n  \n}\n\n\n\n\n\n\n\nFinally, we're expected to provide a render function to the component. Ah ha! We've actually already written a render function for a dropdown -- it's just that the type is wrong.\n\n\nAdapting the render function for \nSelect\n\n\nLet's look at the types side-by-side:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nSelect\n.\nrender\n \n::\n \nSelect\n.\nState\n \nitem\n \neff\n \n-\n \nSelect\n.\nComponentHTML\n \no\n \nitem\n \neff\n\n\n\ndropdown\n \n::\n \nState\n \n-\n \nH\n.\nParentHTML\n \nQuery\n \n(\nChildQuery\n \n(\nEffects\n \neff\n))\n \nChildSlot\n \nm\n\n\ndropdown\n \nst\n \n=\n\n  \nHH\n.\ndiv_\n\n  \n[\n \nHH\n.\nbutton_\n\n    \n[\n \nHH\n.\ntext\n \n$\n \nfromMaybe\n \nClick me to view some items\n \nst\n.\nselectedItem\n \n]\n\n  \n,\n \nif\n \nst\n.\nisOpen\n\n      \nthen\n \nHH\n.\nul_\n \n$\n \n(\n\\\nitem\n \n-\n \nHH\n.\nli_\n \n[\n \nHH\n.\ntext\n \nitem\n \n])\n \n$\n \nst\n.\navailableItems\n\n      \nelse\n \nHH\n.\ntext\n \n\n  \n]\n\n\n\n\n\n\n\nFrom this, we can see that we need to use the state type from \nSelect\n to drive our render function, not the state from our parent component. Will our function still work? Let's look at \nSelect\n's state type in the module documentation\n to see what we have available:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\ntype\n \nState\n \nitem\n \neff\n \n=\n\n  \n{\n \ninputType\n        \n::\n \nInputType\n\n  \n,\n \nsearch\n           \n::\n \nString\n\n  \n,\n \ndebounceTime\n     \n::\n \nMilliseconds\n\n  \n,\n \ndebouncer\n        \n::\n \nMaybe\n \n(\nDebouncer\n \neff\n)\n\n  \n,\n \ninputElement\n     \n::\n \nMaybe\n \nHTMLElement\n\n  \n,\n \nitems\n            \n::\n \nArray\n \nitem\n\n  \n,\n \nvisibility\n       \n::\n \nVisibility\n\n  \n,\n \nhighlightedIndex\n \n::\n \nMaybe\n \nInt\n\n  \n,\n \nlastIndex\n        \n::\n \nInt\n\n  \n}\n\n\n\n\n\n\n\nThat's a lot of stuff! We have some of the data we need in \nSelect\n's state -- we have our list of items and whether the menu is open or closed. We even got new information, like which item is highlighted. But we're missing something crucial: which item is selected.\n\n\nAs a general rule, \nSelect\n does not manage selections on your behalf. You are expected to decide what you want to happen when an item is selected and to store the selections yourself.\n\n\nWhat can we do? We don't have all the information we need to write this function. Or do we?\n\n\nIn fact, \nso long as we write the \nSelect\n render function within the \nwhere\n clause of the parent component's render function\n, we have access to the parent's state! Let's give it a shot.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nrender\n \nparentState\n \n=\n\n  \nHH\n.\ndiv_\n\n  \n[\n \nHH\n.\nh1_\n\n    \n[\n \nHH\n.\ntext\n \nDropdown\n \n]\n\n  \n,\n \nHH\n.\nslot\n \nunit\n \nSelect\n.\ncomponent\n \n?\ninput\n \n(\nHE\n.\ninput\n \n \nconst\n \nNothing\n)\n\n  \n]\n\n  \nwhere\n\n    \ndropdown\n\n      \n::\n \nSelect\n.\nState\n \nString\n \n(\nEffects\n \neff\n)\n\n      \n-\n \nSelect\n.\nComponentHTML\n \nQuery\n \nString\n \n(\nEffects\n \neff\n)\n\n    \ndropdown\n \nchildState\n \n=\n\n      \nHH\n.\ndiv_\n\n      \n[\n \nHH\n.\nbutton_\n\n        \n[\n \nHH\n.\ntext\n \n$\n \nfromMaybe\n \nClick me to view some items\n \nparentState\n.\nselectedItem\n \n]\n\n      \n,\n \nif\n \nchildState\n.\nvisibility\n \n==\n \nSelect\n.\nOn\n\n          \nthen\n \nHH\n.\nul_\n \n$\n \n(\n\\\nitem\n \n-\n \nHH\n.\nli_\n \n[\n \nHH\n.\ntext\n \nitem\n \n])\n \n$\n \nchildState\n.\nitems\n\n          \nelse\n \nHH\n.\ntext\n \n\n      \n]\n\n\n\n\n\n\n\nIt works! Even better, we no longer have to manage things like \nopenState\n in the parent anymore. Finally, now that we have the render function we need, we can finally finish our component's input type:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nrender\n \n::\n \nState\n \n-\n \nH\n.\nParentHTML\n \nQuery\n \n(\nChildQuery\n \n(\nEffects\n \neff\n))\n \nChildSlot\n \nm\n\n\nrender\n \nparentState\n \n=\n\n  \nHH\n.\ndiv_\n\n  \n[\n \nHH\n.\nh1_\n\n    \n[\n \nHH\n.\ntext\n \nDropdown\n \n]\n\n  \n,\n \nHH\n.\nslot\n \nunit\n \nSelect\n.\ncomponent\n \nselectInput\n \n(\nHE\n.\ninput\n \n \nconst\n \nNothing\n)\n\n  \n]\n\n  \nwhere\n\n    \nselectInput\n \n::\n \nSelect\n.\nInput\n \nQuery\n \nString\n \n(\nEffects\n \neff\n)\n\n    \nselectInput\n \n=\n\n      \n{\n \ninputType\n:\n \nSelect\n.\nToggle\n\n      \n,\n \nitems\n:\n \nparentState\n.\navailableItems\n\n      \n,\n \ninitialSearch\n:\n \nNothing\n\n      \n,\n \ndebounceTime\n:\n \nNothing\n\n      \n,\n \nrender\n:\n \ndropdown\n\n      \n}\n\n\n    \ndropdown\n \n=\n \n...\n\n\n\n\n\n\n\nIntegrating Behavior\n\n\nEverything up to this point has been standard Halogen except for writing the child component's render function. At this point, the \nSelect\n component is running -- good work! However, it's not yet \ndoing\n anything.\n\n\nIt's now time to turn your static HTML into a fully-functioning dropdown.\n\n\nAttaching behavior to Select\n\n\nSelect\n works by using a few helper functions that attach at critical points in your render function. The library assumes very little about what your rendering looks like, except that there \nat least\n exists:\n\n\n\n\nOne or more items that can be selected\n\n\nAn element that contains those items\n\n\nA focusable element that can be used to toggle visibility and capture keystrokes\n\n\n\n\nAccordingly, you'll need to use three helper functions, each exported by the \nSelect.Utils.Setters\n module:\n\n\n\n\nsetItemProps\n\n\nsetContainerProps\n\n\nsetToggleProps\n (for toggle-driven input)\n\n\nsetInputProps\n (for text-driven input)\n\n\n\n\nEach of these functions should be used on the property array for the relevant element in your HTML. Let's walk through each one using our built render function.\n\n\nFirst, let's augment our individual items. \nsetItemProps\n takes an index and some properties and outputs some new properties, which include all sorts of event handlers necessary for keyboard events and click events to work. In order to provide it with the index it needs, we'll use the \nmapWithIndex\n function from \nData\n.\nArray\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\nimport\n \nData.Array\n \n(\nmapWithIndex\n)\n\n\n\ndropdown\n \nchildState\n \n=\n\n  \nHH\n.\ndiv_\n\n  \n[\n \nHH\n.\nbutton_\n\n    \n[\n \nHH\n.\ntext\n \n$\n \nfromMaybe\n \nClick me to view some items\n \nparentState\n.\nselectedItem\n \n]\n\n  \n,\n \ncase\n \nchildState\n.\nvisibility\n \nof\n\n      \nSelect\n.\nOff\n \n-\n \nHH\n.\ntext\n \n\n\n      \nSelect\n.\nOn\n \n-\n \nHH\n.\nul\n \n[]\n \n$\n\n        \nmapWithIndex\n\n          \n(\n\\\nix\n \nitem\n \n-\n \nHH\n.\nli\n \n(\nSetters\n.\nsetItemProps\n \nix\n \n[]\n)\n \n[\n \nHH\n.\ntext\n \nitem\n \n])\n\n          \nchildState\n.\nitems\n\n  \n]\n\n\n\n\n\n\n\nNext, we'll move to the element that contains the items. The \nsetContainerProps\n function takes and returns some properties, attaching all the behavior the library needs. We'll use this on the parent element, \nul\n:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\ndropdown\n \nchildState\n \n=\n\n  \nHH\n.\ndiv_\n\n  \n[\n \nHH\n.\nbutton_\n\n    \n[\n \nHH\n.\ntext\n \n$\n \nfromMaybe\n \nClick me to view some items\n \nparentState\n.\nselectedItem\n \n]\n\n  \n,\n \ncase\n \nchildState\n.\nvisibility\n \nof\n\n      \nSelect\n.\nOff\n \n-\n \nHH\n.\ntext\n \n\n\n      \nSelect\n.\nOn\n \n-\n \nHH\n.\nul\n \n(\nSetters\n.\nsetContainerProps\n \n[]\n)\n \n$\n\n        \nmapWithIndex\n\n          \n(\n\\\nix\n \nitem\n \n-\n \nHH\n.\nli\n \n(\nSetters\n.\nsetItemProps\n \nix\n \n[]\n)\n \n[\n \nHH\n.\ntext\n \nitem\n \n])\n\n          \nchildState\n.\nitems\n\n  \n]\n\n\n\n\n\n\n\nFinally, we can make sure that our button toggles the menu on and off, captures keyboard events, can be tabbed to, and all sorts of other stuff with the \nsetToggleProps\n function.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\ndropdown\n \nchildState\n \n=\n\n  \nHH\n.\ndiv_\n\n  \n[\n \nHH\n.\nbutton\n\n    \n(\nSetters\n.\nsetToggleProps\n \n[]\n)\n\n    \n[\n \nHH\n.\ntext\n \n$\n \nfromMaybe\n \nClick me to view some items\n \nparentState\n.\nselectedItem\n \n]\n\n  \n,\n \ncase\n \nchildState\n.\nvisibility\n \nof\n\n      \nSelect\n.\nOff\n \n-\n \nHH\n.\ntext\n \n\n\n      \nSelect\n.\nOn\n \n-\n \nHH\n.\nul\n \n[]\n \n$\n\n        \nmapWithIndex\n\n          \n(\n\\\nix\n \nitem\n \n-\n \nHH\n.\nli\n \n(\nSetters\n.\nsetItemProps\n \nix\n \n[]\n)\n \n[\n \nHH\n.\ntext\n \nitem\n \n])\n\n          \nchildState\n.\nitems\n\n  \n]\n\n\n\n\n\n\n\nWhew! Your rendering code now contains everything it needs to provide a keyboard-accessible dropdown. If you open this up in the browser and click around, you'll notice it's properly toggling and can be tabbed to.\n\n\nLet's make one last improvement. When you use your arrow keys on the dropdown, the highlighted index is changing, but since we didn't provide any CSS we can't see it. Let's add some bare-bones styling so we can watch the highlights:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\nimport\n \nHalogen.HTML.Properties\n \nas\n \nHP\n\n\n\nSelect\n.\nOn\n \n-\n \nHH\n.\nul\n \n(\nSetters\n.\nsetContainerProps\n \n[]\n)\n \n$\n\n  \nmapWithIndex\n\n    \n(\n\\\nix\n \nitem\n \n-\n\n      \nHH\n.\nli\n\n        \n(\n \nSetters\n.\nsetItemProps\n \nix\n\n          \n$\n \ncase\n \nJust\n \nix\n \n==\n \nchildState\n.\nhighlightedIndex\n \nof\n\n              \ntrue\n \n-\n \n[\n \nHP\n.\nattr\n \n(\nHH\n.\nAttrName\n \nstyle\n)\n \ncolor: red;\n \n]\n\n              \n_\n \n-\n \n[]\n \n)\n\n        \n[\n \nHH\n.\ntext\n \nitem\n \n]\n\n    \n)\n\n    \nchildState\n.\nitems\n\n\n\n\n\n\n\nThere we go! Try toggling the menu on and off, using your arrow, enter, and escape keys, and so on. It works!\n\n\n...almost. Alas, we aren't doing anything when the user makes a selection. \nSelect\n is attempting to notify us that a selection occurred, but we never provided a handler. Let's fix that now.\n\n\nHandling messages from Select\n\n\nWhen you add a new child component you invariably need to add a handler for its \nMessage\n type. What should the parent do when something important has occurred in the child? To handle messages, add a new constructor to your query algebra that takes the child's \nMessage\n type as an argument:\n\n\n1\n2\n3\ndata\n \nQuery\n \na\n\n  \n=\n \nNoOp\n \na\n\n  \n|\n \nHandleSelect\n \nSelect\n.\nMessage\n \na\n\n\n\n\n\n\n\nAh -- this won't compile!\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nError\n \nfound\n \nin\n \nmodule\n \nComponent\n:\n\n\n  \nCould\n \nnot\n \nmatch\n \nkind\n\n    \n(\nType\n \n-\n \nType\n)\n \n-\n \nType\n \n-\n \nType\n\n\n  \nwith\n \nkind\n\n    \nType\n\n\n\nin\n \ntype\n \nconstructor\n \nQuery\n\n\n\n\n\n\n\nThis looks similar to the type error we got when we tried to just use \nSelect.Query\n in a type synonym. We need to provide a \nType\n to \nHandleSelect\n, but \nSelect\n.\nMessage\n is still awaiting 2 arguments, the first of which is \nitself\n awaiting an argument! Let's go look at the \nmodule documentation for \nSelect.Message\n.\n\n\n1\ndata\n \nMessage\n \no\n \nitem\n\n\n\n\n\n\n\nWe've seen both of these arguments before in the component's query type, so we should fill them in with the same values. \no\n is our parent component query type, and \nitem\n is a \nString\n:\n\n\n1\n2\n3\ndata\n \nQuery\n \na\n\n  \n=\n \nNoOp\n \na\n\n  \n|\n \nHandleSelect\n \n(\nSelect\n.\nMessage\n \nQuery\n \nString\n)\n \na\n\n\n\n\n\n\n\nAs soon as you save and rebuild you'll see another compiler error!\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nError\n \nfound\n \nin\n \nmodule\n \nComponent\n\n\n  \nA\n \ncase\n \nexpression\n \ncould\n \nnot\n \nbe\n \ndetermined\n \nto\n \ncover\n \nall\n \ninputs\n.\n\n  \nThe\n \nfollowing\n \nadditional\n \ncases\n \nare\n \nrequired\n \nto\n \ncover\n \nall\n \ninputs\n:\n\n\n    \n(\nHandleSelect\n \n_\n \n_\n)\n\n\n\nin\n \nvalue\n \ndeclaration\n \ncomponent\n\n\n\n\n\n\n\nThis time it's because we've added a new query, but we never updated our \neval\n function to describe what should happen when the query is triggered. What should we actually \ndo\n when a message comes up from the child component?\n\n\n\n\nTip\n\n\nYou'll often see type errors that end in \"... value declaration component.\" when the error occurred in any of the functions in the \nwhere\n clause for the component. It can be annoying to track down where the error actually is in your code. One way to help track these down is to move your code out of the \nwhere\n block and into the module level temporarily so the compiler can identify which particular function is causing the issue.\n\n\n\n\nThere are four possible sub-cases that we need to handle, each described in the module documentation:\n\n\n1\n2\n3\n4\n5\ndata\n \nMessage\n \no\n \nitem\n\n  \n=\n \nSearched\n \nString\n\n  \n|\n \nSelected\n \nitem\n\n  \n|\n \nVisibilityChanged\n \nVisibility\n\n  \n|\n \nEmit\n \n(\no\n \nUnit\n)\n\n\n\n\n\n\n\nLet's stub out each of these cases and then decide what to do with them:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\neval\n \n::\n \nQuery\n \n~\n \nH\n.\nParentDSL\n \nState\n \nQuery\n \n(\nChildQuery\n \neff\n)\n \nChildSlot\n \nMessage\n \nm\n\n\neval\n \n=\n \ncase\n \n_\n \nof\n\n  \nNoOp\n \nnext\n \n-\n \npure\n \nnext\n\n\n  \nHandleSelect\n \nmessage\n \nnext\n \n-\n \ncase\n \nmessage\n \nof\n\n    \nSelect\n.\nSearched\n \nstring\n \n-\n\n      \npure\n \nnext\n\n\n    \nSelect\n.\nSelected\n \nitem\n \n-\n\n      \npure\n \nnext\n\n\n    \nSelect\n.\nVisibilityChanged\n \nvis\n \n-\n\n      \npure\n \nnext\n\n\n    \nSelect\n.\nEmit\n \nquery\n \n-\n\n      \npure\n \nnext\n\n\n\n\n\n\n\nLet's take these case-by-case.\n\n\nWhat should we do when the user has searched something on our dropdown? This is just a simple list of items, so we'll simply ignore their search. We can leave this as \npure\n \nnext\n.\n\n\nWhat should we do when the user has selected an item? Ah! This is more interesting. We want to set their item as the currently-selected one, and then we want to remove it from the available items list. Once we've removed it from the available items, we'll update \nSelect\n with its new items to display and we'll toggle it off.\n\n\nWe can use \ndifference\n from \nData\n.\nArray\n to filter out the selected item from the overall list of items. This is a common pattern in \nSelect\n: the parent holds the immutable list of all possible items, and \nSelect\n receives some subset of those items at each render. You might use the user's search to filter out items in a typeahead, for example, or only load 50 results at a time into a dropdown.\n\n\n1\n2\n3\n4\n5\n6\n7\nimport\n \nData.Array\n \n(\ndifference\n)\n\n\n\nSelect\n.\nSelected\n \nitem\n \n-\n \ndo\n\n  \nst\n \n-\n \nH\n.\nget\n\n  \n_\n \n-\n \nH\n.\nquery\n \nunit\n \n$\n \nSelect\n.\nsetVisibility\n \nSelect\n.\nOff\n\n  \n_\n \n-\n \nH\n.\nquery\n \nunit\n \n$\n \nSelect\n.\nreplaceItems\n \n$\n \ndifference\n \nst\n.\navailableItems\n \n[\n \nitem\n \n]\n\n  \nH\n.\nmodify\n \n_\n \n{\n \nselectedItem\n \n=\n \nJust\n \nitem\n \n}\n\n\n\n\n\n\n\nWhat should we do when the dropdown's visibility has changed? This can often be useful to run validation, but for our dropdown, we don't care what its visibility is. We can leave this as \npure\n \nnext\n.\n\n\nFinally, what should we do when the child component raises its \nEmit\n message? What does this even mean? \nEmit\n exists so you can embed your own queries into \nSelect\n and extend its behavior. Since the message contains one of your own queries, all you have to do is evaluate it: you can call \neval\n recursively to run your query.\n\n\nYou can think of \nEmit\n as notifying you that the query you embedded is ready to run.\n\n\n1\n2\n3\nSelect\n.\nEmit\n \nquery\n \n-\n \ndo\n\n  \neval\n \nquery\n\n  \npure\n \nnext\n\n\n\n\n\n\n\nNice and simple! While you may write all kinds of logic for the other messages raised by \nSelect\n, you'll always write this same code for the \nEmit\n message.\n\n\nConclusion\n\n\nCongratulations! You have successfully built a keyboard-navigable dropdown using \nSelect\n. You integrated the library, wrote your own render function, and then augmented it with helper functions from the library. Then, you handled the output messages and sent queries to update the component's state. You've done quite a lot of work!\n\n\n\n\nTip\n\n\nDid you notice anything you would improve about this tutorial or the \nSelect\n library? I'd love to hear about it! Feel free to reach out on the \nfunctional programming Slack\n or on the \nPureScript user forum\n. If you found a bug or would like to make an improvement, please open an issue or pull request on the library.\n\n\n\n\nNext Steps\n\n\nThis tutorial was a slow, thorough introduction to the \nSelect\n library. But we've only scratched the surface of what you can do with it. I'd recommend continuing on to the faster-paced and more advanced \ntypeahead tutorial\n.\n\n\nSource Code\n\n\nIf you'd like to use this component as a starting point from which to build your own, feel free to copy/paste the source code below.\n\n\nFull source code for the tutorial\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\nmodule\n \nComponent\n \nwhere\n\n\n\nimport\n \nPrelude\n\n\n\nimport\n \nControl.Monad.Aff.AVar\n \n(\nAVAR\n)\n\n\nimport\n \nControl.Monad.Aff.Class\n \n(\nclass\n \nMonadAff\n)\n\n\nimport\n \nDOM\n \n(\nDOM\n)\n\n\nimport\n \nData.Array\n \n(\ndifference\n,\n \nmapWithIndex\n)\n\n\nimport\n \nData.Maybe\n \n(\nMaybe\n(\n..\n),\n \nfromMaybe\n)\n\n\nimport\n \nHalogen\n \nas\n \nH\n\n\nimport\n \nHalogen.HTML\n \nas\n \nHH\n\n\nimport\n \nHalogen.HTML.Events\n \nas\n \nHE\n\n\nimport\n \nHalogen.HTML.Properties\n \n(\nattr\n)\n \nas\n \nHP\n\n\nimport\n \nSelect\n \nas\n \nSelect\n\n\nimport\n \nSelect.Utils.Setters\n \nas\n \nSetters\n\n\n\ndata\n \nQuery\n \na\n\n  \n=\n \nHandleSelect\n \n(\nSelect\n.\nMessage\n \nQuery\n \nString\n)\n \na\n\n\n\ntype\n \nState\n \n=\n\n  \n{\n \nisOpen\n \n::\n \nBoolean\n\n  \n,\n \nselectedItem\n \n::\n \nMaybe\n \nString\n\n  \n,\n \navailableItems\n \n::\n \nArray\n \nString\n\n  \n}\n\n\n\ntype\n \nInput\n \n=\n \nUnit\n\n\n\ntype\n \nMessage\n \n=\n \nVoid\n\n\n\ntype\n \nChildSlot\n \n=\n \nUnit\n\n\ntype\n \nChildQuery\n \neff\n \n=\n \nSelect\n.\nQuery\n \nQuery\n \nString\n \neff\n\n\n\ntype\n \nEffects\n \neff\n \n=\n\n  \n(\n \ndom\n \n::\n \nDOM\n\n  \n,\n \navar\n \n::\n \nAVAR\n\n  \n|\n \neff\n\n  \n)\n\n\n\ncomponent\n \n::\n \n\u2200\n \neff\n \nm\n\n  \n.\n \nMonadAff\n \n(\nEffects\n \neff\n)\n \nm\n\n \n=\n \nH\n.\nComponent\n \nHH\n.\nHTML\n \nQuery\n \nInput\n \nMessage\n \nm\n\n\ncomponent\n \n=\n\n  \nH\n.\nparentComponent\n\n    \n{\n \ninitialState\n\n    \n,\n \nrender\n\n    \n,\n \neval\n\n    \n,\n \nreceiver\n:\n \nconst\n \nNothing\n\n    \n}\n\n  \nwhere\n\n\n  \ninitialState\n \n::\n \nInput\n \n-\n \nState\n\n  \ninitialState\n \n=\n \nconst\n\n    \n{\n \nisOpen\n:\n \nfalse\n\n    \n,\n \nselectedItem\n:\n \nNothing\n\n    \n,\n \navailableItems\n:\n\n        \n[\n \nItem One\n\n        \n,\n \nItem Two\n\n        \n,\n \nItem Three\n\n        \n]\n\n    \n}\n\n\n  \nrender\n \n::\n \nState\n \n-\n \nH\n.\nParentHTML\n \nQuery\n \n(\nChildQuery\n \n(\nEffects\n \neff\n))\n \nChildSlot\n \nm\n\n  \nrender\n \nparentState\n \n=\n\n    \nHH\n.\ndiv_\n\n    \n[\n \nHH\n.\nh1_\n\n      \n[\n \nHH\n.\ntext\n \nDropdown\n \n]\n\n    \n,\n \nHH\n.\nslot\n \nunit\n \nSelect\n.\ncomponent\n \nselectInput\n \n(\nHE\n.\ninput\n \nHandleSelect\n)\n\n    \n]\n\n    \nwhere\n\n      \nselectInput\n \n::\n \nSelect\n.\nInput\n \nQuery\n \nString\n \n(\nEffects\n \neff\n)\n\n      \nselectInput\n \n=\n\n        \n{\n \ninputType\n:\n \nSelect\n.\nToggle\n\n        \n,\n \nitems\n:\n \nparentState\n.\navailableItems\n\n        \n,\n \ninitialSearch\n:\n \nNothing\n\n        \n,\n \ndebounceTime\n:\n \nNothing\n\n        \n,\n \nrender\n:\n \ndropdown\n\n        \n}\n\n\n      \ndropdown\n\n        \n::\n \nSelect\n.\nState\n \nString\n \n(\nEffects\n \neff\n)\n\n        \n-\n \nSelect\n.\nComponentHTML\n \nQuery\n \nString\n \n(\nEffects\n \neff\n)\n\n      \ndropdown\n \nchildState\n \n=\n\n        \nHH\n.\ndiv_\n\n        \n[\n \nHH\n.\nbutton\n\n          \n(\nSetters\n.\nsetToggleProps\n \n[]\n)\n\n          \n[\n \nHH\n.\ntext\n \n$\n \nfromMaybe\n \nClick me to view some items\n \nparentState\n.\nselectedItem\n \n]\n\n        \n,\n \ncase\n \nchildState\n.\nvisibility\n \nof\n\n            \nSelect\n.\nOff\n \n-\n \nHH\n.\ntext\n \n\n\n            \nSelect\n.\nOn\n \n-\n \nHH\n.\nul\n \n(\nSetters\n.\nsetContainerProps\n \n[]\n)\n \n$\n\n              \nmapWithIndex\n\n                \n(\n\\\nix\n \nitem\n \n-\n\n                  \nHH\n.\nli\n\n                    \n(\n \nSetters\n.\nsetItemProps\n \nix\n\n                      \n$\n \ncase\n \nJust\n \nix\n \n==\n \nchildState\n.\nhighlightedIndex\n \nof\n\n                          \ntrue\n \n-\n \n[\n \nHP\n.\nattr\n \n(\nHH\n.\nAttrName\n \nstyle\n)\n \ncolor: red;\n \n]\n\n                          \n_\n \n-\n \n[]\n \n)\n\n                    \n[\n \nHH\n.\ntext\n \nitem\n \n]\n\n                \n)\n\n                \nchildState\n.\nitems\n\n        \n]\n\n\n  \neval\n \n::\n \nQuery\n \n~\n \nH\n.\nParentDSL\n \nState\n \nQuery\n \n(\nChildQuery\n \n(\nEffects\n \neff\n))\n \nChildSlot\n \nMessage\n \nm\n\n  \neval\n \n=\n \ncase\n \n_\n \nof\n\n    \nHandleSelect\n \nmessage\n \nnext\n \n-\n \ncase\n \nmessage\n \nof\n\n      \nSelect\n.\nSearched\n \nstring\n \n-\n\n        \npure\n \nnext\n\n\n      \nSelect\n.\nSelected\n \nitem\n \n-\n \ndo\n\n        \nst\n \n-\n \nH\n.\nget\n\n        \n_\n \n-\n \nH\n.\nquery\n \nunit\n \n$\n \nSelect\n.\nsetVisibility\n \nSelect\n.\nOff\n\n        \n_\n \n-\n \nH\n.\nquery\n \nunit\n \n$\n \nSelect\n.\nreplaceItems\n \n$\n \ndifference\n \nst\n.\navailableItems\n \n[\n \nitem\n \n]\n\n        \nH\n.\nmodify\n \n_\n \n{\n \nselectedItem\n \n=\n \nJust\n \nitem\n \n}\n\n        \npure\n \nnext\n\n\n      \nSelect\n.\nVisibilityChanged\n \nvis\n \n-\n\n        \npure\n \nnext\n\n\n      \nSelect\n.\nEmit\n \nquery\n \n-\n \ndo\n\n        \neval\n \nquery\n\n        \npure\n \nnext",
            "title": "Build a dropdown"
        },
        {
            "location": "/tutorials/dropdown/#lets-build-a-dropdown-in-purescript",
            "text": "Dropdowns are among the simplest selection components you will build, but they can be tricky to get right. For example, you'll likely want to ensure that your users can type to highlight close text matches (like when you type \"Ca\" to highlight \"California\" in a state dropdown). You'll want to be accessible to folks using screen readers or keyboard-only navigation, too. And, of course, you'll want to achieve all this without compromising on your design.  This tutorial is intended as a beginner-friendly, thorough introduction to  Select . We'll build a functional dropdown complete with keyboard navigation. Along the way, we'll learn more about how to work with Halogen components, diagnose type errors, and other common PureScript tasks.   Info  This tutorial assumes you've followed the steps in the  Project Setup  section. While not necessary, this code is tested with those steps in mind.  It also assumes familiarity with the Halogen framework. If you need a refresher, try the official  Halogen guide  or the  whirlwind tour  of our starter component.   If you are already an intermediate or advanced PureScript developer, then this tutorial will read slowly for you. Feel free to skim, get the gist of how the library works, and then move on to the  faster-paced and more advanced typeahead tutorial .   Your code should work at the end of every step. If you run into issues or your code doesn't compile, please come visit us on the  PureScript user forum  or the  #fpchat Slack channel .   We're going to build a dropdown that is functionally equivalent this one:   Our component will look a little bit worse, because we're not going to spend time on CSS.",
            "title": "Let's Build a Dropdown in PureScript!"
        },
        {
            "location": "/tutorials/dropdown/#basic-setup",
            "text": "Let's get something on the screen!  The simplest sort of dropdown has a button that can toggle a menu open or closed, a list of items that can be selected from that menu, and zero, one, or more selected items. For our dropdown we'll assume that you can select at most one item, and that selecting an item will replace the text on the button with that item.",
            "title": "Basic Setup"
        },
        {
            "location": "/tutorials/dropdown/#rendering-a-button-and-items",
            "text": "We'll start by rendering the button and the items. At this point our render function contains only an empty div, so let's fill in the rest of the HTML we need:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 render   ::   State   -   H . ParentHTML   Query   ChildQuery   ChildSlot   m  render   st   = \n   HH . div_ \n   [   HH . h1_ \n     [   HH . text   Dropdown   ] \n   ,   HH . button_ \n     [   HH . text   Click me to view some items   ] \n   ,   HH . ul_ \n     [   HH . li_ \n       [   HH . text   Item 1   ] \n     ,   HH . li_ \n       [   HH . text   Item 2   ] \n     ] \n   ]     Make sure to compile this code and view the new output! You should see a header, a button, and two items in the list. After each step, make sure your code still compiles.",
            "title": "Rendering a button and items"
        },
        {
            "location": "/tutorials/dropdown/#a-better-state-type",
            "text": "It's already clear we're going to need more than  Unit  for our  State  type. We at least need to know three things:   If the menu is toggled on or off  The currently-selected item (if there is one)  The list of items available for selection   We can represent each of these with simple types in our state:  1\n2\n3\n4\n5 type   State   = \n   {   isOpen   ::   Boolean \n   ,   selectedItem   ::   Maybe   String \n   ,   availableItems   ::   Array   String \n   }    Now that our state contains these three fields, we need to update our  initialState  function to produce the right type of values:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 initialState   ::   Input   -   State  initialState   =   const \n   {   isOpen :   false \n   ,   selectedItem :   Nothing \n   ,   availableItems : \n       [   Item One \n       ,   Item Two \n       ,   Item Three \n       ] \n   }    Finally, lets update our render function to leverage the information now contained in  State . If there's a selected item, that will be the button's text; if not, we'll fall back to a default message. If the menu is open, we'll list out the available items for selection.  For code clarity, we'll also break out the dropdown into its own helper function.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 import   Data.Maybe   ( fromMaybe )  render   ::   State   -   H . ParentHTML   Query   ChildQuery   ChildSlot   m  render   st   = \n   HH . div_ \n   [   HH . h1_ \n     [   HH . text   Dropdown   ] \n   ,   dropdown   st \n   ]  dropdown   ::   State   -   H . ParentHTML   Query   ChildQuery   ChildSlot   m  dropdown   = \n   HH . div_ \n   [   HH . button_ \n     [   HH . text   $   fromMaybe   Click me to view some items   st . selectedItem   ] \n   ,   if   st . isOpen \n       then   HH . ul_   $   ( \\ item   -   HH . li_   [   HH . text   item   ])   $   st . availableItems \n       else   HH . text   \n   ]     Tip  Since the dropdown has no behavior yet, try changing the  initialState  to set  isOpen  to  true  to verify your items are in fact being rendered out to the page.   It ain't pretty, but at this point we've got all the rendering we need for a basic dropdown! The next step is to actually wire in some behavior.",
            "title": "A better State type"
        },
        {
            "location": "/tutorials/dropdown/#integrating-the-component",
            "text": "Let's integrate the  Select  component! In just a few steps, we'll turn our simple render function into a fully-functioning dropdown with keyboard navigation, toggling, debounced type-to-search, and several other features.",
            "title": "Integrating the component"
        },
        {
            "location": "/tutorials/dropdown/#on-building-components-with-select",
            "text": "The key idea behind the  Select  library is to  provide behaviors, not rendering . The core component the library exposes doesn't have a render function at all! Of course, all Halogen components require a render function to work, and  Select  is no different.  You  are expected to provide that render function.  Why?  When you write the render function, not the library, you get to decide exactly what your component will look and feel like. You can also control what queries to trigger from HTML and when, effectively allowing you to control the behavior of the component  without configuration . You can even extend it with new behavior and new state by using information from your parent component. The end result is a much smaller library component with a lot more flexibility and power for you.  We just wrote the rendering we need for an (admittedly ugly) dropdown. The render function we just wrote can actually serve almost as-is as the render function for  Select ! All we have to do is mount the  Select  component, make a few tweaks to our render code, and then pass in a little configuration information. Let's do that next.",
            "title": "On building components with Select"
        },
        {
            "location": "/tutorials/dropdown/#importing-the-select-component",
            "text": "The first thing we'll do is bring in the  Select  library in the first place.  1\n2 import   Select   as   Select  import   Select.Utils.Setters   as   Setters     Tip  You can always  view the module documentation for Select on Pursuit  or the  source code on GitHub . This is useful when integrating with third-party components so that you can check out the  Input ,  State ,  Query , and  Message  types.   Next, we need to update our  ChildSlot  and  ChildQuery  types. We're only going to have one dropdown so we can leave the child slot as  Unit ; we do need to add the  Select  component's query type to our  ChildQuery  synonym, however.  This code, unfortunately, won't work:  1\n2\n3\n4\n5\n6\n7 type   ChildQuery   =   Select . Query  Error   found : \n   Type   synonym   Select . Query   is   partially   applied . \n   Type   synonyms   must   be   applied   to   all   of   their   type   arguments .  in   type   synonym   ChildQuery    The compiler has noticed that  ChildQuery , a type synonym, is partially applied. That's because  Select . Query , itself a type synonym, takes several arguments as described in the  module documentation on Pursuit . Let's walk through each one:  1 type   ChildQuery   o   item   eff   =   Select . Query   o   item   eff    o  is  your  query type. Remember how you can embed your own queries into  Select , and in that way extend the component's functionality? This is how. So we can fill in the first argument:  1 type   ChildQuery   item   eff   =   Select . Query   Query   item   eff    item  is the type of whatever items you want to be selectable. Commonly these are strings, but can also be custom data types. Later on, in the  typeahead tutorial , we'll see how powerful custom data types can be for rendering purposes. For our simple dropdown we'll simply specialize this to  String :  1 type   ChildQuery   eff   =   Select . Query   Query   String   eff    eff  is the type of whatever effect rows your component leverages.  Select  performs some effects, like manipulating the DOM or using threads to perform debouncing on your behalf asynchronously, and it must verify that its effects match your parent component effects. We'll leave this as an argument for now, but when we mount the component, we'll provide some concrete effects.  What happens if we try to save this?  1\n2\n3\n4\n5\n6\n7\n8\n9 Error   found   in   module   Component   : \n\n   Could   not   match   kind \n     Type \n\n   with   kind \n     #   Control . Monad . Eff . Effect  while   checking   the   kind   of   State   -   ParentHTML   Query   ChildQuery   ChildSlot   m0    Whoops! Our  render  and  eval  functions expect  ChildQuery  to have the kind  Type , but instead we've provided a type synonym that's still awaiting an argument of kind  #   Effect  (read: a row of effects). We need to supply that argument. Let's update those two functions:  1\n2\n3 render   ::   State   -   H . ParentHTML   Query   ( ChildQuery   eff )   ChildSlot   m  dropdown   ::   State   -   H . ParentHTML   Query   ( ChildQuery   eff )   ChildSlot   m  eval   ::   Query   ~   H . ParentDSL   State   Query   ( ChildQuery   eff )   ChildSlot   Message   m    Now that  Select  has been imported and we've updated our  ChildQuery  and  ChildSlot  types to support it, we can worry about what to do when we receive a message from the component.",
            "title": "Importing the Select component"
        },
        {
            "location": "/tutorials/dropdown/#mounting-the-component",
            "text": "We're finally ready to mount the  Select  component. Mounting any component in Halogen requires supplying a slot value, the component itself, the component's input, and the component's handler. We can put together all of these except for the input, which we haven't prepared yet.  Let's stub out our render function in preparation:  1\n2\n3\n4\n5\n6\n7\n8\n9 import   Halogen.HTML.Events   as   HE  render   ::   State   -   H . ParentHTML   Query   ( ChildQuery   eff )   ChildSlot   m  render   st   = \n   HH . div_ \n   [   HH . h1_ \n     [   HH . text   Dropdown   ] \n   ,   HH . slot   unit   Select . component   ? input   ( HE . input     const   Nothing ) \n   ]    Right away we get an error:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 Error   in   module   Component : \n\n   Could   not   match   type \n     eff7 \n\n   with   type \n     (   dom   ::   DOM \n     ,   avar   ::   AVAR \n     |   eff7 \n     )  when   trying   to   match   type   QueryF   Query   String   eff7 \n   with   type   QueryF   Query   String    This happened because  Select  uses the  AVAR  and  DOM  effects, but we've asserted our component will work with ANY row. That's not true anymore! Our component will now work with any row that includes  DOM  and  AVAR . It's easy enough to fix. We need to define our own effects row, extensible by  eff :  1\n2\n3\n4\n5\n6\n7\n8 import   Control.Monad.Aff.AVar   ( AVAR )  import   DOM   ( DOM )  type   Effects   eff   = \n   (   dom   ::   DOM \n   ,   avar   ::   AVAR \n   |   eff \n   )    Now we can update our various types to use our new row, verifying the effects are the same throughout the component. As a rule of thumb, anywhere a  function  uses  eff , wrap it in our new  Effects  type synonym, but don't apply the same rule to types or type synonyms. As an example, we'll update  component , but we won't update the  ChildQuery  type synonym:  1\n2\n3\n4\n5\n6\n7 component   ::   \u2200   eff   m \n   .   MonadAff   ( Effects   eff )   m \n  =   H . Component   HH . HTML   Query   Input   Message   m  render   ::   State   -   H . ParentHTML   Query   ( ChildQuery   ( Effects   eff ))   ChildSlot   m  dropdown   ::   State   -   H . ParentHTML   Query   ( ChildQuery   ( Effects   eff ))   ChildSlot   m  eval   ::   Query   ~   H . ParentDSL   State   Query   ( ChildQuery   ( Effects   eff ))   ChildSlot   Message   m    With that out of the way, we can turn to filling in our component's input type. We can either look at the module documentation for  Select.Input  or look at the type error that resulted from our typed hole,  ?input . Both will tell us that we need to provide a value of this type:  1\n2\n3\n4\n5\n6\n7 type   Input   o   item   eff   = \n   {   inputType       ::   InputType \n   ,   items           ::   Array   item \n   ,   initialSearch   ::   Maybe   String \n   ,   debounceTime    ::   Maybe   Milliseconds \n   ,   render          ::   State   item   eff   -   ComponentHTML   o   item   eff \n   }    Let's build this up, step by step. First, we see we have to provide an  InputType . This is described in the module documentation:  1\n2\n3\n4\n5\n6 -- | Text-driven inputs will operate like a normal search-driven selection component.  -- | Toggle-driven inputs will capture key streams and debounce in reverse (only notify  -- | about searches when time has expired).  data   InputType \n   =   TextInput \n   |   Toggle    We don't have any text input for our dropdown -- its a button -- so we'll go with the  Toggle  constructor.  1\n2\n3\n4\n5 selectInput   ::   Select . Input   Query   String   ( Effects   eff )  selectInput   = \n   {   inputType :   Select . Toggle \n   ,   ... \n   }    Next, we're expected to provide an array of items. Fortunately we already have those in our  State . We can just send those items directly into the input.  1\n2\n3\n4 selectInput   = \n   {   ... \n   ,   items :   st . availableItems \n   }    Next, we're expected to provide an initial search. This would be more useful if we had a text input, but for our dropdown, we'll start off with no initial search.  1\n2\n3\n4 selectInput   = \n   {   ... \n   ,   initialSearch :   Nothing \n   }    What about a debounce time? For toggle-driven components, this is how long to aggregate key presses before the user's typing should affect the list of items. For search-driven components, this is how long to delay before raising a message with the new search. For our dropdown, we don't care:  1\n2\n3\n4 selectInput   = \n   {   ... \n   ,   debounceTime :   Nothing \n   }    Finally, we're expected to provide a render function to the component. Ah ha! We've actually already written a render function for a dropdown -- it's just that the type is wrong.",
            "title": "Mounting the component"
        },
        {
            "location": "/tutorials/dropdown/#adapting-the-render-function-for-select",
            "text": "Let's look at the types side-by-side:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 Select . render   ::   Select . State   item   eff   -   Select . ComponentHTML   o   item   eff  dropdown   ::   State   -   H . ParentHTML   Query   ( ChildQuery   ( Effects   eff ))   ChildSlot   m  dropdown   st   = \n   HH . div_ \n   [   HH . button_ \n     [   HH . text   $   fromMaybe   Click me to view some items   st . selectedItem   ] \n   ,   if   st . isOpen \n       then   HH . ul_   $   ( \\ item   -   HH . li_   [   HH . text   item   ])   $   st . availableItems \n       else   HH . text   \n   ]    From this, we can see that we need to use the state type from  Select  to drive our render function, not the state from our parent component. Will our function still work? Let's look at  Select 's state type in the module documentation  to see what we have available:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 type   State   item   eff   = \n   {   inputType          ::   InputType \n   ,   search             ::   String \n   ,   debounceTime       ::   Milliseconds \n   ,   debouncer          ::   Maybe   ( Debouncer   eff ) \n   ,   inputElement       ::   Maybe   HTMLElement \n   ,   items              ::   Array   item \n   ,   visibility         ::   Visibility \n   ,   highlightedIndex   ::   Maybe   Int \n   ,   lastIndex          ::   Int \n   }    That's a lot of stuff! We have some of the data we need in  Select 's state -- we have our list of items and whether the menu is open or closed. We even got new information, like which item is highlighted. But we're missing something crucial: which item is selected.  As a general rule,  Select  does not manage selections on your behalf. You are expected to decide what you want to happen when an item is selected and to store the selections yourself.  What can we do? We don't have all the information we need to write this function. Or do we?  In fact,  so long as we write the  Select  render function within the  where  clause of the parent component's render function , we have access to the parent's state! Let's give it a shot.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18 render   parentState   = \n   HH . div_ \n   [   HH . h1_ \n     [   HH . text   Dropdown   ] \n   ,   HH . slot   unit   Select . component   ? input   ( HE . input     const   Nothing ) \n   ] \n   where \n     dropdown \n       ::   Select . State   String   ( Effects   eff ) \n       -   Select . ComponentHTML   Query   String   ( Effects   eff ) \n     dropdown   childState   = \n       HH . div_ \n       [   HH . button_ \n         [   HH . text   $   fromMaybe   Click me to view some items   parentState . selectedItem   ] \n       ,   if   childState . visibility   ==   Select . On \n           then   HH . ul_   $   ( \\ item   -   HH . li_   [   HH . text   item   ])   $   childState . items \n           else   HH . text   \n       ]    It works! Even better, we no longer have to manage things like  openState  in the parent anymore. Finally, now that we have the render function we need, we can finally finish our component's input type:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18 render   ::   State   -   H . ParentHTML   Query   ( ChildQuery   ( Effects   eff ))   ChildSlot   m  render   parentState   = \n   HH . div_ \n   [   HH . h1_ \n     [   HH . text   Dropdown   ] \n   ,   HH . slot   unit   Select . component   selectInput   ( HE . input     const   Nothing ) \n   ] \n   where \n     selectInput   ::   Select . Input   Query   String   ( Effects   eff ) \n     selectInput   = \n       {   inputType :   Select . Toggle \n       ,   items :   parentState . availableItems \n       ,   initialSearch :   Nothing \n       ,   debounceTime :   Nothing \n       ,   render :   dropdown \n       } \n\n     dropdown   =   ...",
            "title": "Adapting the render function for Select"
        },
        {
            "location": "/tutorials/dropdown/#integrating-behavior",
            "text": "Everything up to this point has been standard Halogen except for writing the child component's render function. At this point, the  Select  component is running -- good work! However, it's not yet  doing  anything.  It's now time to turn your static HTML into a fully-functioning dropdown.",
            "title": "Integrating Behavior"
        },
        {
            "location": "/tutorials/dropdown/#attaching-behavior-to-select",
            "text": "Select  works by using a few helper functions that attach at critical points in your render function. The library assumes very little about what your rendering looks like, except that there  at least  exists:   One or more items that can be selected  An element that contains those items  A focusable element that can be used to toggle visibility and capture keystrokes   Accordingly, you'll need to use three helper functions, each exported by the  Select.Utils.Setters  module:   setItemProps  setContainerProps  setToggleProps  (for toggle-driven input)  setInputProps  (for text-driven input)   Each of these functions should be used on the property array for the relevant element in your HTML. Let's walk through each one using our built render function.  First, let's augment our individual items.  setItemProps  takes an index and some properties and outputs some new properties, which include all sorts of event handlers necessary for keyboard events and click events to work. In order to provide it with the index it needs, we'll use the  mapWithIndex  function from  Data . Array .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 import   Data.Array   ( mapWithIndex )  dropdown   childState   = \n   HH . div_ \n   [   HH . button_ \n     [   HH . text   $   fromMaybe   Click me to view some items   parentState . selectedItem   ] \n   ,   case   childState . visibility   of \n       Select . Off   -   HH . text   \n\n       Select . On   -   HH . ul   []   $ \n         mapWithIndex \n           ( \\ ix   item   -   HH . li   ( Setters . setItemProps   ix   [] )   [   HH . text   item   ]) \n           childState . items \n   ]    Next, we'll move to the element that contains the items. The  setContainerProps  function takes and returns some properties, attaching all the behavior the library needs. We'll use this on the parent element,  ul :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 dropdown   childState   = \n   HH . div_ \n   [   HH . button_ \n     [   HH . text   $   fromMaybe   Click me to view some items   parentState . selectedItem   ] \n   ,   case   childState . visibility   of \n       Select . Off   -   HH . text   \n\n       Select . On   -   HH . ul   ( Setters . setContainerProps   [] )   $ \n         mapWithIndex \n           ( \\ ix   item   -   HH . li   ( Setters . setItemProps   ix   [] )   [   HH . text   item   ]) \n           childState . items \n   ]    Finally, we can make sure that our button toggles the menu on and off, captures keyboard events, can be tabbed to, and all sorts of other stuff with the  setToggleProps  function.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 dropdown   childState   = \n   HH . div_ \n   [   HH . button \n     ( Setters . setToggleProps   [] ) \n     [   HH . text   $   fromMaybe   Click me to view some items   parentState . selectedItem   ] \n   ,   case   childState . visibility   of \n       Select . Off   -   HH . text   \n\n       Select . On   -   HH . ul   []   $ \n         mapWithIndex \n           ( \\ ix   item   -   HH . li   ( Setters . setItemProps   ix   [] )   [   HH . text   item   ]) \n           childState . items \n   ]    Whew! Your rendering code now contains everything it needs to provide a keyboard-accessible dropdown. If you open this up in the browser and click around, you'll notice it's properly toggling and can be tabbed to.  Let's make one last improvement. When you use your arrow keys on the dropdown, the highlighted index is changing, but since we didn't provide any CSS we can't see it. Let's add some bare-bones styling so we can watch the highlights:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 import   Halogen.HTML.Properties   as   HP  Select . On   -   HH . ul   ( Setters . setContainerProps   [] )   $ \n   mapWithIndex \n     ( \\ ix   item   - \n       HH . li \n         (   Setters . setItemProps   ix \n           $   case   Just   ix   ==   childState . highlightedIndex   of \n               true   -   [   HP . attr   ( HH . AttrName   style )   color: red;   ] \n               _   -   []   ) \n         [   HH . text   item   ] \n     ) \n     childState . items    There we go! Try toggling the menu on and off, using your arrow, enter, and escape keys, and so on. It works!  ...almost. Alas, we aren't doing anything when the user makes a selection.  Select  is attempting to notify us that a selection occurred, but we never provided a handler. Let's fix that now.",
            "title": "Attaching behavior to Select"
        },
        {
            "location": "/tutorials/dropdown/#handling-messages-from-select",
            "text": "When you add a new child component you invariably need to add a handler for its  Message  type. What should the parent do when something important has occurred in the child? To handle messages, add a new constructor to your query algebra that takes the child's  Message  type as an argument:  1\n2\n3 data   Query   a \n   =   NoOp   a \n   |   HandleSelect   Select . Message   a    Ah -- this won't compile!  1\n2\n3\n4\n5\n6\n7\n8\n9 Error   found   in   module   Component : \n\n   Could   not   match   kind \n     ( Type   -   Type )   -   Type   -   Type \n\n   with   kind \n     Type  in   type   constructor   Query    This looks similar to the type error we got when we tried to just use  Select.Query  in a type synonym. We need to provide a  Type  to  HandleSelect , but  Select . Message  is still awaiting 2 arguments, the first of which is  itself  awaiting an argument! Let's go look at the  module documentation for  Select.Message .  1 data   Message   o   item    We've seen both of these arguments before in the component's query type, so we should fill them in with the same values.  o  is our parent component query type, and  item  is a  String :  1\n2\n3 data   Query   a \n   =   NoOp   a \n   |   HandleSelect   ( Select . Message   Query   String )   a    As soon as you save and rebuild you'll see another compiler error!  1\n2\n3\n4\n5\n6\n7\n8 Error   found   in   module   Component \n\n   A   case   expression   could   not   be   determined   to   cover   all   inputs . \n   The   following   additional   cases   are   required   to   cover   all   inputs : \n\n     ( HandleSelect   _   _ )  in   value   declaration   component    This time it's because we've added a new query, but we never updated our  eval  function to describe what should happen when the query is triggered. What should we actually  do  when a message comes up from the child component?   Tip  You'll often see type errors that end in \"... value declaration component.\" when the error occurred in any of the functions in the  where  clause for the component. It can be annoying to track down where the error actually is in your code. One way to help track these down is to move your code out of the  where  block and into the module level temporarily so the compiler can identify which particular function is causing the issue.   There are four possible sub-cases that we need to handle, each described in the module documentation:  1\n2\n3\n4\n5 data   Message   o   item \n   =   Searched   String \n   |   Selected   item \n   |   VisibilityChanged   Visibility \n   |   Emit   ( o   Unit )    Let's stub out each of these cases and then decide what to do with them:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 eval   ::   Query   ~   H . ParentDSL   State   Query   ( ChildQuery   eff )   ChildSlot   Message   m  eval   =   case   _   of \n   NoOp   next   -   pure   next \n\n   HandleSelect   message   next   -   case   message   of \n     Select . Searched   string   - \n       pure   next \n\n     Select . Selected   item   - \n       pure   next \n\n     Select . VisibilityChanged   vis   - \n       pure   next \n\n     Select . Emit   query   - \n       pure   next    Let's take these case-by-case.  What should we do when the user has searched something on our dropdown? This is just a simple list of items, so we'll simply ignore their search. We can leave this as  pure   next .  What should we do when the user has selected an item? Ah! This is more interesting. We want to set their item as the currently-selected one, and then we want to remove it from the available items list. Once we've removed it from the available items, we'll update  Select  with its new items to display and we'll toggle it off.  We can use  difference  from  Data . Array  to filter out the selected item from the overall list of items. This is a common pattern in  Select : the parent holds the immutable list of all possible items, and  Select  receives some subset of those items at each render. You might use the user's search to filter out items in a typeahead, for example, or only load 50 results at a time into a dropdown.  1\n2\n3\n4\n5\n6\n7 import   Data.Array   ( difference )  Select . Selected   item   -   do \n   st   -   H . get \n   _   -   H . query   unit   $   Select . setVisibility   Select . Off \n   _   -   H . query   unit   $   Select . replaceItems   $   difference   st . availableItems   [   item   ] \n   H . modify   _   {   selectedItem   =   Just   item   }    What should we do when the dropdown's visibility has changed? This can often be useful to run validation, but for our dropdown, we don't care what its visibility is. We can leave this as  pure   next .  Finally, what should we do when the child component raises its  Emit  message? What does this even mean?  Emit  exists so you can embed your own queries into  Select  and extend its behavior. Since the message contains one of your own queries, all you have to do is evaluate it: you can call  eval  recursively to run your query.  You can think of  Emit  as notifying you that the query you embedded is ready to run.  1\n2\n3 Select . Emit   query   -   do \n   eval   query \n   pure   next    Nice and simple! While you may write all kinds of logic for the other messages raised by  Select , you'll always write this same code for the  Emit  message.",
            "title": "Handling messages from Select"
        },
        {
            "location": "/tutorials/dropdown/#conclusion",
            "text": "Congratulations! You have successfully built a keyboard-navigable dropdown using  Select . You integrated the library, wrote your own render function, and then augmented it with helper functions from the library. Then, you handled the output messages and sent queries to update the component's state. You've done quite a lot of work!   Tip  Did you notice anything you would improve about this tutorial or the  Select  library? I'd love to hear about it! Feel free to reach out on the  functional programming Slack  or on the  PureScript user forum . If you found a bug or would like to make an improvement, please open an issue or pull request on the library.",
            "title": "Conclusion"
        },
        {
            "location": "/tutorials/dropdown/#next-steps",
            "text": "This tutorial was a slow, thorough introduction to the  Select  library. But we've only scratched the surface of what you can do with it. I'd recommend continuing on to the faster-paced and more advanced  typeahead tutorial .",
            "title": "Next Steps"
        },
        {
            "location": "/tutorials/dropdown/#source-code",
            "text": "If you'd like to use this component as a starting point from which to build your own, feel free to copy/paste the source code below.  Full source code for the tutorial   1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121 module   Component   where  import   Prelude  import   Control.Monad.Aff.AVar   ( AVAR )  import   Control.Monad.Aff.Class   ( class   MonadAff )  import   DOM   ( DOM )  import   Data.Array   ( difference ,   mapWithIndex )  import   Data.Maybe   ( Maybe ( .. ),   fromMaybe )  import   Halogen   as   H  import   Halogen.HTML   as   HH  import   Halogen.HTML.Events   as   HE  import   Halogen.HTML.Properties   ( attr )   as   HP  import   Select   as   Select  import   Select.Utils.Setters   as   Setters  data   Query   a \n   =   HandleSelect   ( Select . Message   Query   String )   a  type   State   = \n   {   isOpen   ::   Boolean \n   ,   selectedItem   ::   Maybe   String \n   ,   availableItems   ::   Array   String \n   }  type   Input   =   Unit  type   Message   =   Void  type   ChildSlot   =   Unit  type   ChildQuery   eff   =   Select . Query   Query   String   eff  type   Effects   eff   = \n   (   dom   ::   DOM \n   ,   avar   ::   AVAR \n   |   eff \n   )  component   ::   \u2200   eff   m \n   .   MonadAff   ( Effects   eff )   m \n  =   H . Component   HH . HTML   Query   Input   Message   m  component   = \n   H . parentComponent \n     {   initialState \n     ,   render \n     ,   eval \n     ,   receiver :   const   Nothing \n     } \n   where \n\n   initialState   ::   Input   -   State \n   initialState   =   const \n     {   isOpen :   false \n     ,   selectedItem :   Nothing \n     ,   availableItems : \n         [   Item One \n         ,   Item Two \n         ,   Item Three \n         ] \n     } \n\n   render   ::   State   -   H . ParentHTML   Query   ( ChildQuery   ( Effects   eff ))   ChildSlot   m \n   render   parentState   = \n     HH . div_ \n     [   HH . h1_ \n       [   HH . text   Dropdown   ] \n     ,   HH . slot   unit   Select . component   selectInput   ( HE . input   HandleSelect ) \n     ] \n     where \n       selectInput   ::   Select . Input   Query   String   ( Effects   eff ) \n       selectInput   = \n         {   inputType :   Select . Toggle \n         ,   items :   parentState . availableItems \n         ,   initialSearch :   Nothing \n         ,   debounceTime :   Nothing \n         ,   render :   dropdown \n         } \n\n       dropdown \n         ::   Select . State   String   ( Effects   eff ) \n         -   Select . ComponentHTML   Query   String   ( Effects   eff ) \n       dropdown   childState   = \n         HH . div_ \n         [   HH . button \n           ( Setters . setToggleProps   [] ) \n           [   HH . text   $   fromMaybe   Click me to view some items   parentState . selectedItem   ] \n         ,   case   childState . visibility   of \n             Select . Off   -   HH . text   \n\n             Select . On   -   HH . ul   ( Setters . setContainerProps   [] )   $ \n               mapWithIndex \n                 ( \\ ix   item   - \n                   HH . li \n                     (   Setters . setItemProps   ix \n                       $   case   Just   ix   ==   childState . highlightedIndex   of \n                           true   -   [   HP . attr   ( HH . AttrName   style )   color: red;   ] \n                           _   -   []   ) \n                     [   HH . text   item   ] \n                 ) \n                 childState . items \n         ] \n\n   eval   ::   Query   ~   H . ParentDSL   State   Query   ( ChildQuery   ( Effects   eff ))   ChildSlot   Message   m \n   eval   =   case   _   of \n     HandleSelect   message   next   -   case   message   of \n       Select . Searched   string   - \n         pure   next \n\n       Select . Selected   item   -   do \n         st   -   H . get \n         _   -   H . query   unit   $   Select . setVisibility   Select . Off \n         _   -   H . query   unit   $   Select . replaceItems   $   difference   st . availableItems   [   item   ] \n         H . modify   _   {   selectedItem   =   Just   item   } \n         pure   next \n\n       Select . VisibilityChanged   vis   - \n         pure   next \n\n       Select . Emit   query   -   do \n         eval   query \n         pure   next",
            "title": "Source Code"
        },
        {
            "location": "/tutorials/typeahead/",
            "text": "Let's Build a Typeahead in PureScript!\n\n\nTypeaheads are among the most common selection components you'll build. Most web developers have had to implement at least one of these before and they can be surprisingly difficult to build. Luckily, with \nSelect\n, implementing a typeahead that fits your custom design takes little more than writing the rendering code and then tweaking it with a helper function or two.\n\n\nIn this tutorial we'll build a typeahead with the following features:\n\n\n\n\nUsers can search Star Wars characters by name; their searches will be debounced automatically and results will be fetched asynchronously.\n\n\nThe typeahead should support keyboard-only use: arrow keys should step up and down the items, Enter should select, Escape should close, and so on.\n\n\nThe typeahead should manage its own selections, including insertion and removal, and should notify its parent when the selections have changed.\n\n\nIf a search returns no results, then there should be an embedded \"fetch data\" button the user can click to force a request with an empty search. It should display within the list of items.\n\n\n\n\nAlong the way, we'll see how to extend \nSelect\n's features by embedding parent queries (we'll use this to embed the \"fetch data\" button in the list).\n\n\n\n\nInfo\n\n\nThis tutorial assumes you've followed the steps in the \nProject Setup\n section. While not necessary, this code is tested with those steps in mind.\n\n\nIt also assumes familiarity with Halogen and intermediate PureScript experience or that you have already completed the \nmore thorough, beginner-friendly dropdown tutorial\n. If you need a Halogen refresher, try the official \nHalogen guide\n or the \nwhirlwind tour\n of our starter component.\n\n\nYour code should work at the end of every step. If you run into issues or your code doesn't compile, please come visit us on the \nPureScript user forum\n or the \n#fpchat Slack channel\n.\n\n\n\n\nBasic Setup\n\n\nIn this tutorial, we'll build a typeahead component from scratch. You can either follow along using the minimal component from the \nProject Setup section\n or start your own.\n\n\nIf you didn't follow the project setup, grab the source for our starting component here:\n\n\nSource code for a minimal starting component\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\nmodule\n \nComponent\n \nwhere\n\n\n\nimport\n \nPrelude\n\n\n\nimport\n \nControl.Monad.Aff.Class\n \n(\nclass\n \nMonadAff\n)\n\n\nimport\n \nData.Const\n \n(\nConst\n)\n\n\nimport\n \nData.Maybe\n \n(\nMaybe\n(\n..\n))\n\n\nimport\n \nHalogen\n \nas\n \nH\n\n\nimport\n \nHalogen.HTML\n \nas\n \nHH\n\n\n\ndata\n \nQuery\n \na\n\n  \n=\n \nNoOp\n \na\n\n\n\ntype\n \nState\n \n=\n \nUnit\n\n\ntype\n \nInput\n \n=\n \nUnit\n\n\n\ntype\n \nMessage\n \n=\n \nVoid\n\n\n\ntype\n \nChildSlot\n \n=\n \nUnit\n\n\ntype\n \nChildQuery\n \n=\n \nConst\n \nVoid\n\n\n\ncomponent\n \n::\n \n\u2200\n \neff\n \nm\n\n  \n.\n \nMonadAff\n \neff\n \nm\n\n \n=\n \nH\n.\nComponent\n \nHH\n.\nHTML\n \nQuery\n \nInput\n \nMessage\n \nm\n\n\ncomponent\n \n=\n\n  \nH\n.\nparentComponent\n\n    \n{\n \ninitialState\n\n    \n,\n \nrender\n\n    \n,\n \neval\n\n    \n,\n \nreceiver\n:\n \nconst\n \nNothing\n\n    \n}\n\n  \nwhere\n\n\n  \ninitialState\n \n::\n \nInput\n \n-\n \nState\n\n  \ninitialState\n \n=\n \nconst\n \nunit\n\n\n  \nrender\n \n::\n \nState\n \n-\n \nH\n.\nParentHTML\n \nQuery\n \nChildQuery\n \nChildSlot\n \nm\n\n  \nrender\n \nst\n \n=\n \nHH\n.\ndiv_\n \n[]\n\n\n  \neval\n \n::\n \nQuery\n \n~\n \nH\n.\nParentDSL\n \nState\n \nQuery\n \nChildQuery\n \nChildSlot\n \nMessage\n \nm\n\n  \neval\n \n=\n \ncase\n \n_\n \nof\n\n    \nNoOp\n \nnext\n \n-\n \npure\n \nnext\n\n\n\n\n\n\nInstall dependencies\n\n\nThe first thing we'll do is make sure we have the libraries we need installed. Our typeahead is going to make API calls on our behalf, decode the response, and keep track of the state of requests using a special \nRemoteData\n data type. Let's go ahead and install our dependencies:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# These should already be installed as part of the project setup\n\nbower i --save purescript-halogen purescript-halogen-select purescript-affjax\n\n\n# These are new dependencies\n\nbower i --save purescript-argonaut purescript-remotedata\n\n\n# Let\ns compile the new dependencies to ensure they\nre available to import\n\nyarn build\n\n\n\n\n\n\nIntegrate the component\n\n\nNow let's make sure we have \nSelect\n ready to go in our component. Import the library:\n\n\n1\n2\nimport\n \nSelect\n \nas\n \nSelect\n\n\nimport\n \nSelect.Utils.Setters\n \nas\n \nSetters\n\n\n\n\n\n\n\nNext, since \nSelect\n is going to be a child component, we'll need to update several types and functions. We will:\n\n\n\n\nDelete the unnecessary \nNoOp\n query and relevant case in \neval\n\n\nAdd a new query to handle messages emitted by \nSelect\n\n\nUpdate our \nChildQuery\n type synonym to contain \nSelect\n's query type\n\n\nUpdate the type signatures for \neval\n and \nrender\n with the new \nChildQuery\n\n\nAdd a new case to \neval\n for our new \nHandleSelect\n query\n\n\n\n\n\n\nTip\n\n\nThis tutorial doesn't explain things like child queries, slots, inputs, rendering, \nFree\n, \neval\n functions, or other crucial Halogen knowledge. If you feel lost, I'd recommend checking out the \ndropdown tutorial\n before continuing.\n\n\n\n\nOf course, we won't be prepared to handle messages or use \nSelect\n's queries without knowing what they are. Let's start with the query type for the \nSelect\n component, \nQueryF\n:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n-- | - `o`: The query type of the component that will mount this component in a child slot.\n\n\n-- |        This allows you to embed your own queries into the `Select` component.\n\n\n-- | - `item`: Your custom item type. It can be a simple type like `String`, or something\n\n\n-- |           complex like `CalendarItem StartDate EndDate (Maybe Disabled)`.\n\n\n-- | - `eff`: The component\ns effects.\n\n\ndata\n \nQueryF\n \no\n \nitem\n \neff\n \na\n\n  \n=\n \nSearch\n \nString\n \na\n\n  \n|\n \nHighlight\n \nTarget\n \na\n\n  \n|\n \nSelect\n \nInt\n \na\n\n  \n|\n \nCaptureRef\n \nET\n.\nEvent\n \na\n\n  \n|\n \nFocus\n \nBoolean\n \na\n\n  \n|\n \nKey\n \nKE\n.\nKeyboardEvent\n \na\n\n  \n|\n \nPreventClick\n \nME\n.\nMouseEvent\n \na\n\n  \n|\n \nSetVisibility\n \nVisibility\n \na\n\n  \n|\n \nGetVisibility\n \n(\nVisibility\n \n-\n \na\n)\n\n  \n|\n \nReplaceItems\n \n(\nArray\n \nitem\n)\n \na\n\n  \n|\n \nRaise\n \n(\no\n \nUnit\n)\n \na\n\n  \n|\n \nReceive\n \n(\nInput\n \no\n \nitem\n \neff\n)\n \na\n\n\n\n\n\n\n\nAlready we're faced with an interesting decision: how should we fill in the type variables that \nSelect\n expects? Two of them are straightforward:\n\n\n\n\no\n represents the type of queries that can be embedded in the component. You should fill this in with your parent component's query type. If you follow Halogen convention and name your type \nQuery\n, then filling this variable in will produce \nSelect\n.\nQuery\n \nQuery\n \nitem\n \neff\n. If you take a look at where this variable is used, you'll see it shows up in the \nSelect\n component's \nRaise\n and \nReceive\n queries. The \nRaise\n query is a wrapper that you can use to embed your query into the render function you provide to the component. The \nReceive\n query leverages \nSelect\n's \nInput\n type, which includes that render function. I'll have a lot more to say about embedding your own query type into \nSelect\n later on.\n\n\neff\n is the effect row that the \nSelect\n component is going to use. The component uses \nDOM\n and \nAVAR\n effects. \neff\n is required for the \nState\n type, which is itself in the type for the render function, which is itself passed to \nSelect\n via the component's \nInput\n type, which is handled with the \nReceive\n query, and so you'll see the type variable present in all the key component types.\n\n\n\n\nThe second type argument is more interesting. \nSelect\n allows you to provide any type as your selectable \"item\". While in this tutorial we're going to stick with strings you could very well make a significantly more information-rich type.\n\n\nWriting useful item types\nAny time you need to render some items differently than others, or you need different logic for when one item is selected vs. another, you should encode that information in the item type. For example, at CitizenNet, our calendar component has an item type like this:\n1\ndata\n \nCalendarItem\n \n=\n \nCalendarItem\n \nSelectedStatus\n \nDisabledStatus\n \nBoundary\n \nRange\n \nDate\n\n\n\n\n\n\nThese custom types give us everything we need to know to render various dates and handle them when selected. For example, if you want some items to be selectable and others to be disabled, you could create an item type like this:\n1\n2\n3\n4\n5\n6\ndata\n \nItem\n \n=\n \nSelectable\n \nString\n \n|\n \nDisabled\n \nString\n\n\n\nrenderItem\n \nix\n \n(\nSelectable\n \nstr\n)\n\n  \n=\n \nHH\n.\nli\n \n(\n \nSetters\n.\nsetItemProps\n \nix\n \n[\n \n]\n \n)\n \n[\n \nHH\n.\ntext\n \nstr\n \n]\n\n\nrenderItem\n \n_\n \n(\nDisabled\n \nstr\n)\n\n  \n=\n \nHH\n.\nli_\n  \n[\n \nHH\n.\ntext\n \nstr\n \n]\n\n\n\n\n\n\nWith all this information in mind, let's go ahead and make those changes:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\ndata\n \nQuery\n \na\n\n  \n=\n \nHandleSelect\n \n(\nSelect\n.\nMessage\n \nQuery\n \nString\n)\n \na\n\n\n\ntype\n \nChildSlot\n \n=\n \nUnit\n\n\ntype\n \nChildQuery\n \neff\n \n=\n \nSelect\n.\nQuery\n \nQuery\n \nString\n \neff\n\n\n\ncomponent\n \n=\n\n  \n...\n\n  \nrender\n \n::\n \nState\n \n-\n \nH\n.\nParentHTML\n \nQuery\n \n(\nChildQuery\n \neff\n)\n \nChildSlot\n \nm\n\n  \nrender\n \nst\n \n=\n \nHH\n.\ndiv_\n \n[]\n\n\n  \neval\n \n::\n \nQuery\n \n~\n \nH\n.\nParentDSL\n \nState\n \nQuery\n \n(\nChildQuery\n \neff\n)\n \nChildSlot\n \nMessage\n \nm\n\n  \neval\n \n=\n \ncase\n \n_\n \nof\n\n    \n-- We\nll just stub this out for the time being.\n\n    \nHandleSelect\n \nmessage\n \nnext\n \n-\n \npure\n \nnext\n\n\n\n\n\n\n\nNext, we'll actually mount the \nSelect\n component. We have everything except for the component's \nInput\n type so far, so we'll fill that in and leave the input as a type hole.\n\n\n1\n2\n3\n4\n5\n6\nimport\n \nHalogen.HTML.Events\n \nas\n \nHE\n\n\n\nrender\n \n::\n \nState\n \n-\n \nH\n.\nParentHTML\n \nQuery\n \n(\nChildQuery\n \neff\n)\n \nChildSlot\n \nm\n\n\nrender\n \nst\n \n=\n\n    \nHH\n.\ndiv_\n\n    \n[\n \nHH\n.\nslot\n \nunit\n \nSelect\n.\ncomponent\n \n?\ninput\n \n(\nHE\n.\ninput\n \nHandleSelect\n)\n \n]\n\n\n\n\n\n\n\nRight away we get a type error:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nError\n \nfound\n \nin\n \nmodule\n \nComponent\n\n\n  \nCould\n \nnot\n \nmatch\n \ntype\n\n\n        \n(\n \navar\n \n::\n \nAVAR\n\n        \n,\n \ndom\n \n::\n \nDOM\n\n        \n|\n \nt2\n\n        \n)\n\n\n    \nwith\n \ntype\n\n\n        \neff0\n\n\n\nwhile\n \ntrying\n \nto\n \nmatch\n \ntype\n\n\n    \nQueryF\n \nQuery\n \nString\n\n        \n(\n \navar\n \n::\n \nAVAR\n\n        \n,\n \ndom\n \n::\n \nDOM\n\n        \n|\n \nt2\n\n        \n)\n\n\n    \nwith\n \ntype\n \nQueryF\n \nQuery\n \nString\n \neff0\n\n\n\nin\n \nvalue\n \ndeclaration\n \ncomponent\n\n\n\n\n\n\n\nIt's an easy fix: we've stated that our component can use any row of effects, but \nSelect\n requires at least \nAVAR\n and \nDOM\n. The component uses \nAVAR\n in order to implement debouncing, and since it manipulates the DOM, it needs the relevant effect. We need to add these effects to the parent component, too. We already know our component is going to make API calls on our behalf, so we'll add the \nAJAX\n effect as well.\n\n\nOnce we've created our \nEffects\n type, we'll need to apply it to every function that uses the \neff\n variable (but not to type synonyms).\n\n\nWhy apply \nEffects\n to function signatures, not type synonyms?\nEffect rows can be surprisingly finicky to get right, especially when you have multiple levels of components and your code becomes more complex. Type synonyms help make your functions more readable by hiding unnecessary details, but in the case of effect rows, they tend to make it much more difficult to debug issues when two rows that are meant to unify don't. At CitizenNet, we follow a rule of thumb to always apply effects in function signatures, but not in type synonyms.\nThat's why, as a general rule, you won't see this in our code:\n1\ntype\n \nChildQuery\n \neff\n \n=\n \nSelect\n.\nQuery\n \nQuery\n \nString\n \n(\nEffects\n \neff\n)\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\nimport\n \nControl.Monad.Aff.AVar\n \n(\nAVAR\n)\n\n\nimport\n \nDOM\n \n(\nDOM\n)\n\n\nimport\n \nNetwork.HTTP.Affjax\n \n(\nAJAX\n)\n\n\n\ntype\n \nEffects\n \neff\n \n=\n\n  \n(\n \navar\n \n::\n \nAVAR\n\n  \n,\n \ndom\n \n::\n \nDOM\n\n  \n,\n \najax\n \n::\n \nAJAX\n\n  \n|\n \neff\n\n  \n)\n\n\n\ncomponent\n \n::\n \n\u2200\n \neff\n \nm\n\n  \n.\n \nMonadAff\n \n(\nEffects\n \neff\n)\n \nm\n\n \n=\n \nH\n.\nComponent\n \nHH\n.\nHTML\n \nQuery\n \nInput\n \nMessage\n \nm\n\n\n  \nrender\n \n::\n \nState\n \n-\n \nH\n.\nParentHTML\n \nQuery\n \n(\nChildQuery\n \n(\nEffects\n \neff\n))\n \nChildSlot\n \nm\n\n  \neval\n \n::\n \nQuery\n \n~\n \nH\n.\nParentDSL\n \nState\n \nQuery\n \n(\nChildQuery\n \n(\nEffects\n \neff\n))\n \nChildSlot\n \nMessage\n \nm\n\n\n\n\n\n\n\nWith that out of the way, we can turn to the component's input type. Here's what we're required to fill in, as per the \nSelect\n module documentation\n:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n-- | Text-driven inputs will operate like a normal search-driven selection component.\n\n\n-- | Toggle-driven inputs will capture key streams and debounce in reverse (only notify\n\n\n-- | about searches when time has expired).\n\n\ndata\n \nInputType\n\n  \n=\n \nTextInput\n\n  \n|\n \nToggle\n\n\n\n-- | The component\ns input type, which includes the component\ns render function. This\n\n\n-- | render function can also be used to share data with the parent component, as every\n\n\n-- | time the parent re-renders, the render function will refresh in `Select`.\n\n\ntype\n \nInput\n \no\n \nitem\n \neff\n \n=\n\n  \n{\n \ninputType\n     \n::\n \nInputType\n\n  \n,\n \nitems\n         \n::\n \nArray\n \nitem\n\n  \n,\n \ninitialSearch\n \n::\n \nMaybe\n \nString\n\n  \n,\n \ndebounceTime\n  \n::\n \nMaybe\n \nMilliseconds\n\n  \n,\n \nrender\n        \n::\n \nState\n \nitem\n \neff\n \n-\n \nComponentHTML\n \no\n \nitem\n \neff\n\n  \n}\n\n\n\n\n\n\n\nLet's look at these one-by-one:\n\n\n\n\nWe're using an input field in the DOM, so we'll use the \nTextInput\n type to drive the component.\n\n\nWe don't have any items yet (they'll be fetched via the Star Wars API), so we'll provide an empty array.\n\n\nWe don't want there to be an initial search; we'll wait for the user to type something. However, if at any point we want to fill in text in the input field (for example, set the text to the full selection when the user selects something), we can use this field to accomplish that.\n\n\nWe're making API calls every time the user performs a search, so we'll set a reasonable debounce time of a few hundred milliseconds.\n\n\nAh, the big issue: we need to write a render function and pass it in to the component. We don't have one yet, so we'll stub this out with a simple empty \ndiv\n.\n\n\n\n\nLet's write that input record now:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nimport\n \nData.Time.Duration\n \n(\nMilliseconds\n(\n..\n))\n\n\n\nrender\n \n::\n \nState\n \n-\n \nH\n.\nParentHTML\n \nQuery\n \n(\nChildQuery\n \n(\nEffects\n \neff\n))\n \nChildSlot\n \nm\n\n\nrender\n \nst\n \n=\n\n  \nHH\n.\ndiv_\n\n  \n[\n \nHH\n.\nslot\n \nunit\n \nSelect\n.\ncomponent\n \nselectInput\n \n(\nHE\n.\ninput\n \nHandleSelect\n)\n \n]\n\n\n\nselectInput\n \n::\n \nSelect\n.\nInput\n \nQuery\n \nString\n \n(\nEffects\n \neff\n)\n\n\nselectInput\n \n=\n\n  \n{\n \ninputType\n:\n \nSelect\n.\nTextInput\n\n  \n,\n \nitems\n:\n \n[]\n\n  \n,\n \ninitialSearch\n:\n \nNothing\n\n  \n,\n \ndebounceTime\n:\n \nJust\n \n$\n \nMilliseconds\n \n250.0\n\n  \n,\n \nrender\n:\n \n\\\n_\n \n-\n \nHH\n.\ndiv_\n \n[\n \nHH\n.\ntext\n \nNot implemented\n \n]\n\n  \n}\n\n\n\n\n\n\n\nAll right! We've fully integrated the \nSelect\n component. It's a little tedious to integrate the component the first time you do it, but it soon becomes second nature. At this point, we're ready to start writing our typeahead.\n\n\n\n\nNow would be a good time to verify that this component is rendering properly. Compile the project and point your browser to \ndist/index.html\n. You should see text rendering from within \nSelect\n.\n\n\n\n\nA minimal typeahead\n\n\nLet's take a step back now that we have \nSelect\n integrated. We are building a typeahead that will fetch some data asynchronously when the user makes a search. It needs to maintain a list of items that can be selected, and a list of items that have already been selected. The user should only be able to select any item once, so these two lists should have no shared items. We'd like the typeahead to handle all the data fetching and selections behind the scenes, and only notify the parent component when the selections have been updated.\n\n\nWith this information in mind, we can step through the key data types in our Halogen component and ensure they accurately capture the features we want.\n\n\n\n\nNote\n\n\nIn the dropdown tutorial, we started by writing a render function and only later worried about state, queries, messages, and so on. However, I usually like to work in the other direction. We already know the behaviors and data we need to manage, and we don't need to render anything to implement them, though we'll certainly use our rendered component for testing.\n\n\nInstead, we'll work through the major data types in our component and only once those are completed will we write some minimal rendering code. It might feel a little strange to spend so much time on data without once touching the HTML, but by the time we reach our rendering function it will naturally extend from the data.\n\n\n\n\nState\n\n\nFrom our requirements, we know we'll need some information:\n\n\n\n\nA list of items that can be selected by the user\n\n\nA list of items that have already been selected, and which can be removed\n\n\nThe user's last search, so we can use it to fetch new data from the Star Wars API\n\n\n\n\nIt'll also be nice to have some extra information purely for rendering purposes, like:\n\n\n\n\nAn indicator as to whether the menu should be displayed or not\n\n\nAn indicator as to which item the user has focused, so we can highlight it\n\n\n\n\nWe have access to two distinct \nState\n types when we use \nSelect\n: the parent component state, which we own, and the \nSelect\n component's state, which we can read and write. There's no point in duplicating information between the two if we can help it. But we have access to even more information: messages output by the component. Sometimes we can simply rely on the contents of these messages to take action without ever storing the result in state.\n\n\nLet's take a quick look at what \nSelect\n provides (take a look at the \nmodule documentation\n for more details):\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\ntype\n \nState\n \nitem\n \neff\n \n=\n\n  \n{\n \ninputType\n        \n::\n \nInputType\n\n  \n,\n \nsearch\n           \n::\n \nString\n\n  \n,\n \ndebounceTime\n     \n::\n \nMilliseconds\n\n  \n,\n \ndebouncer\n        \n::\n \nMaybe\n \n(\nDebouncer\n \neff\n)\n\n  \n,\n \ninputElement\n     \n::\n \nMaybe\n \nHTMLElement\n\n  \n,\n \nitems\n            \n::\n \nArray\n \nitem\n\n  \n,\n \nvisibility\n       \n::\n \nVisibility\n\n  \n,\n \nhighlightedIndex\n \n::\n \nMaybe\n \nInt\n\n  \n,\n \nlastIndex\n        \n::\n \nInt\n\n  \n}\n\n\n\ndata\n \nMessage\n \no\n \nitem\n\n  \n=\n \nSearched\n \nString\n\n  \n|\n \nSelected\n \nitem\n\n  \n|\n \nVisibilityChanged\n \nVisibility\n\n  \n|\n \nEmit\n \n(\no\n \nUnit\n)\n\n\n\n\n\n\n\nIt looks like we already have the list of selectable items stored in \nSelect\n, so we don't need that in our component state. We're fetching new items via an external API, so after each new search we can simply pass the new items straight down.\n\n\nWe also have the user's search stored in \nState\n and also raised as a message every time the debouncer runs out. We don't really care about every keystroke the user types, so we'll rely on the \nSearched\n message for this information.\n\n\nWe have our two pieces of rendering information, too, with the \nvisibility\n and \nhighlightedIndex\n fields.\n\n\nIn fact, it looks like the only thing we have to store in our \nState\n is the list of selecetions! That keeps things simple.\n\n\n1\ntype\n \nState\n \n=\n \n{\n \nselections\n \n::\n \nArray\n \nString\n \n}\n\n\n\n\n\n\n\n\n\nTip\n\n\nSelect\n doesn't manage any selections on your behalf. What should happen when an item gets selected, after all? In some cases, you might want to stick it into a \"selected\" list and remove it from the list of available options. In others, you might want it to be selectable multiple times. Or you might want to just apply a highlight, like in a calendar picker. Rather than force you to fill out a configuration record, \nSelect\n defers the decision to you.\n\n\n\n\nThis is OK, but I'd like some more information. We're fetching data asynchronously, right? That means that requests could possibly fail, or they might be in progress for a long time, or perhaps they might never get triggered in the first place. Ideally our typeahead could render differently depending on these states. If we don't keep track of our requests in \nState\n, we won't have any of this information available for rendering.\n\n\nIt's the same idea as using an information-rich custom \nitem\n type to add nuance to your rendering code. Luckily, there already exists a lovely package named \npurescript-remotedata\n that supplies us with a data type we can use to model each of these states:\n\n\n1\n2\n3\n4\n5\ndata\n \nRemoteData\n \ne\n \na\n\n  \n=\n \nNotAsked\n\n  \n|\n \nLoading\n\n  \n|\n \nFailure\n \ne\n\n  \n|\n \nSuccess\n \na\n\n\n\n\n\n\n\nSo while it's not strictly necessary to maintain a list of items in our state, we'll leverage \nRemoteData\n to have a more useful state type.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\ntype\n \nState\n \n=\n\n  \n{\n \nitems\n \n::\n \nRemoteData\n \nString\n \n(\nArray\n \nString\n)\n\n  \n,\n \nselections\n \n::\n \nArray\n \nString\n\n  \n}\n\n\n\ninitialState\n \n::\n \nInput\n \n-\n \nState\n\n\ninitialState\n \n=\n \nconst\n\n  \n{\n \nitems\n:\n \nNotAsked\n\n  \n,\n \nselections\n:\n \n[]\n\n  \n}\n\n\n\n\n\n\n\nQuery\n\n\nNow that we've got a usable \nState\n type, let's turn to our queries. Queries are the computations available to the component, so they're the place where we ought to think about what the typeahead should \ndo\n, rather than just how it should render.\n\n\nJust like \nState\n, when we write our own \nQuery\n type on top of \nSelect\n, we should consider what is already available in the component. As usual, we'll turn to the \nmodule documentation\n to look at our available queries. I'd recommend scrolling through the available functions to get a glimpse of what \nSelect\n offers, but we'll skip to the main points here.\n\n\nSelect\n is going to manage all the keyboard events, text input, debouncing, moving the highlighted index, and so on. On top of that, we'll need to add some extra functionality: the ability to remove items that have already been selected, and the ability to fetch new items when the user performs a search. We'll at least need two queries to handle these two features.\n\n\nLuckily, though, we already \nhave\n a query available for when a new search has been performed: our \nHandleSelect\n query tied to the \nSelect\n.\nSearched\n message! That means we really only need one new query:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\ndata\n \nQuery\n \na\n\n  \n=\n \nHandleSelect\n \n(\nSelect\n.\nMessage\n \nQuery\n \nString\n)\n \na\n\n  \n|\n \nRemove\n \nString\n \na\n\n\n\neval\n \n::\n \nQuery\n \n~\n \nH\n.\nParentDSL\n \nState\n \nQuery\n \n(\nChildQuery\n \n(\nEffects\n \neff\n))\n \nChildSlot\n \nMessage\n \nm\n\n\neval\n \n=\n \ncase\n \n_\n \nof\n\n  \nHandleSelect\n \nmessage\n \nnext\n \n-\n \ncase\n \nmessage\n \nof\n\n    \nSelect\n.\nSearched\n \nstr\n \n-\n\n      \npure\n \nnext\n\n    \nSelect\n.\nSelected\n \nitem\n \n-\n\n      \npure\n \nnext\n\n    \nSelect\n.\nVisibilityChanged\n \nvis\n \n-\n\n      \npure\n \nnext\n\n    \nSelect\n.\nEmit\n \nquery\n \n-\n\n      \npure\n \nnext\n\n\n  \nRemove\n \nitem\n \nnext\n \n-\n\n    \npure\n \nnext\n\n\n\n\n\n\n\nWhat do we want to happen in each of these queries? Let's work from the bottom to the top.\n\n\nRemove\n\n\nWhen the user clicks on an item that is already selected, we want to remove it from the selected list. We also want to re-insert it into the available items in \nSelect\n. It's easy enough to accomplish this:\n\n\n1\n2\n3\n4\n5\n6\n7\nRemove\n \nitem\n \nnext\n \n-\n \ndo\n\n  \nH\n.\nmodify\n \n\\\nst\n \n-\n \nst\n \n{\n \nselections\n \n=\n \nfilter\n \n(\n_\n \n/=\n \nitem\n)\n \nst\n.\nselections\n \n}\n\n  \nst\n \n-\n \nH\n.\nget\n\n  \n_\n \n-\n \nH\n.\nquery\n \nunit\n\n    \n$\n \nSelect\n.\nreplaceItems\n\n    \n$\n \ndifference\n \n(\nwithDefault\n \n[]\n \nst\n.\nitems\n)\n \nst\n.\nselections\n\n  \npure\n \nnext\n\n\n\n\n\n\n\nEmit\n\n\nWhat should we do when we get the \nEmit\n message? This is returning our own query to us so we can run it, so we can recursively call \neval\n with the query. You'll use this pattern every time you implement a new component with \nSelect\n:\n\n\n1\nSelect\n.\nEmit\n \nquery\n \n-\n \neval\n \nquery\n \n*\n \npure\n \nnext\n\n\n\n\n\n\n\nVisibilityChange\n\n\nWhat about when the visibility changes? We don't actually care about this one, so we'll ignore it. It's useful for validation, if we were to implement that.\n\n\nSelected\n\n\nWhat about when an item is selected? This one is like the inverse of our \nRemove\n query. We want to remove the item from the available items and add it to the list of selections.\n\n\n1\n2\n3\n4\n5\n6\n7\nSelect\n.\nSelected\n \nitem\n \n-\n \ndo\n\n  \nH\n.\nmodify\n \n\\\nst\n \n-\n \nst\n \n{\n \nselections\n \n=\n \nitem\n \n:\n \nst\n.\nselections\n \n}\n\n  \nst\n \n-\n \nH\n.\nget\n\n  \n_\n \n-\n \nH\n.\nquery\n \nunit\n\n    \n$\n \nSelect\n.\nreplaceItems\n\n    \n$\n \ndifference\n \n(\nwithDefault\n \n[]\n \nst\n.\nitems\n)\n \nst\n.\nselections\n\n  \npure\n \nnext\n\n\n\n\n\n\n\nSearched\n\n\nWe can finally consider what to do when the user performs a search. We won't do any fancy filtering on our own; we're going to punt that responsibility to an external API. Still, now we have to write the code to fetch that data.\n\n\nOur function will hit the Star Wars API, decode the result into an array of strings, and then return them. In the case of failure, we'll return an error message.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nimport\n \nData.Argonaut\n \n(\nJson\n,\n \ndecodeJson\n,\n \n(\n.?\n))\n\n\nimport\n \nNetwork.HTTP.Affjax\n \n(\nAJAX\n,\n \nget\n)\n\n\n\nfetchItems\n \n::\n \nString\n \n-\n \nAff\n \n(\nEffects\n \neff\n)\n \n(\nEither\n \nString\n \n(\nArray\n \nString\n))\n\n\nfetchItems\n \nstr\n \n=\n \ndo\n\n  \n(\nres\n \n::\n \nJson\n)\n \n-\n \n_\n.\nresponse\n\n    \n$\n \nget\n \n(\nhttps://swapi.co/api/people/?search=\n \n \nstr\n)\n\n\n  \npure\n \n$\n \ndo\n\n    \nobj\n \n-\n \ndecodeJson\n \nres\n\n    \narr\n \n-\n \nobj\n \n.?\n \nresults\n\n    \ntraverse\n \n(\ndecodeJson\n \n=\n \nflip\n \n(\n.?\n)\n \nname\n)\n \narr\n\n\n\n\n\n\n\nNow that we have this helper function, we can handle new searches that users perform. First, we'll put our typeahead into the \nLoading\n state to represent an ongoing request. Then, we'll empty out the old items in \nSelect\n to avoid out-of-sync data. Then, we'll fetch and decode our items, convert the result from \nEither\n to \nRemoteData\n, and finally set it on \nState\n.\n\n\nOnce our new items have been set, we can use the result to update \nSelect\n just like we did when we handled new selections or removals.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nSelect\n.\nSearched\n \nstring\n \n-\n \ndo\n\n  \nH\n.\nmodify\n \n_\n \n{\n \nitems\n \n=\n \nLoading\n \n}\n\n  \n_\n \n-\n \nH\n.\nquery\n \nunit\n \n$\n \nSelect\n.\nreplaceItems\n \n[]\n\n  \nnewItems\n \n-\n \nH\n.\nliftAff\n \n(\nfetchItems\n \nstring\n)\n\n  \nH\n.\nmodify\n \n_\n \n{\n \nitems\n \n=\n \nfromEither\n \nnewItems\n \n}\n\n\n  \nst\n \n-\n \nH\n.\nget\n\n  \n_\n \n-\n \nH\n.\nquery\n \nunit\n\n    \n$\n \nSelect\n.\nreplaceItems\n\n    \n$\n \ndifference\n \n(\nwithDefault\n \n[]\n \nst\n.\nitems\n)\n \nst\n.\nselections\n\n\n\n\n\n\n\nThat's it! Our typeahead has all the logic necessary to function as required. All that's left to do is actually write the render function.\n\n\nRendering\n\n\nWe have all the state and behavior necessary to run a working typeahead. Now, let's write the render function.\n\n\nWhen you write a render function for a \nSelect\n component, keep in mind that the function is going to be run \nby\n the child component. You can see this right away from the type signature of the render function that \nSelect\n expects:\n\n\n1\nmyRenderFunction\n \n::\n \nSelect\n.\nState\n \nitem\n \neff\n \n-\n \nSelect\n.\nComponentHTML\n \no\n \nitem\n \neff\n\n\n\n\n\n\n\nIn our case, we've already specialized our parent query, item, and effects, so the type signature is actually this:\n\n\n1\n2\n3\nmyRenderFunction\n\n  \n::\n \nSelect\n.\nState\n \nString\n \n(\nEffects\n \neff\n)\n\n  \n-\n \nSelect\n.\nComponentHTML\n \nQuery\n \nString\n \n(\nEffects\n \neff\n)\n\n\n\n\n\n\n\n\n\nTip\n\n\nWhen you write a component with \nSelect\n, you'll usually want access to the parent component's state and query algebra. This is what makes the pattern powerful: you can use any values from your state in the render function you provide to \nSelect\n, and you can embed any queries from your query algebra, too. Most of the time developers will stay in scope with the parent component by writing the \nSelect\n render function within a \nwhere\n clause. However, you could also write a render function outside the parent component so long as it takes the parent state as an argument, like this:\n\n\n1\n2\n3\n4\nselectRenderFunction\n\n  \n::\n \nParent\n.\nState\n\n  \n-\n \nSelect\n.\nState\n \nString\n \n(\nParent\n.\nEffects\n \neff\n)\n\n  \n-\n \nSelect\n.\nComponentHTML\n \nParent\n.\nQuery\n \nString\n \n(\nParent\n.\nEffects\n \neff\n)\n\n\n\n\n\n\n\nThen you can write this render function anywhere you'd like while retaining access to the parent's state and query algebra. \nSelect\n will not accept this function as-is, however; you'll need to apply it to the parent state before sending the function in as input:\n\n\n1\nselectInput\n \n=\n \n{\n \n...\n,\n \nrender\n:\n \nselectRenderFunction\n \nparentState\n,\n \n...\n \n}\n\n\n\n\n\n\n\n\n\nSince you write the render function to pass to Select, you retain full control of the design and most of the structure of your HTML. All that \nSelect\n expects from you is that you apply the three helper functions from \nSetters\n:\n\n\n\n\nsetItemProps\n on each item that can be selected\n\n\nsetContainerProps\n on the parent HTML element of all the items\n\n\nsetInputProps\n on the text input\n\n\n\n\nFor this reason, I usually break my component's render function into three helpers. Let's go ahead and write our render function for the typeahead.\n\n\nOur overall function is going to take the parent state, the \nSelect\n state, and output the \nSelect\n component HTML type:\n\n\n1\n2\n3\n4\n5\ntypeahead\n\n  \n::\n \nState\n\n  \n-\n \nSelect\n.\nState\n \nString\n \n(\nEffects\n \neff\n)\n\n  \n-\n \nSelect\n.\nComponentHTML\n \nQuery\n \nString\n \n(\nEffects\n \neff\n)\n\n\ntypeahead\n \nparentState\n \nchildState\n \n=\n \n...\n\n\n\n\n\n\n\nLet's write this function from top to bottom. We want our typeahead to have the list of selected items above the input field, then the input field, then the list of available items (if there are any). Ultimately, with helper functions, we'd like to write this:\n\n\n1\n2\n3\n4\n5\ntypeahead\n \nparentState\n \nchildState\n \n=\n\n  \nHH\n.\ndiv_\n\n  \n[\n \nrenderSelections\n,\n \nrenderInput\n,\n \nrenderContainer\n \n]\n\n  \nwhere\n\n    \n...\n\n\n\n\n\n\n\nLet's start with the first one: \nrenderSelections\n. This function will leverage only the parent state, which contains the selections, and won't use anything from \nSelect\n.\n\n\n\n\nTip\n\n\nIn fact you don't need to render the selections inside \nSelect\n at all -- you could render the selections first, and then mount the \nSelect\n component below. We use this approach for our own typeaheads at CitizenNet. However, embedding the selections into the \nSelect\n component allows me to show off how embedding parent queries works and it's an equally viable design, so that's the approach taken here.\n\n\n\n\nWe're just going to render an unordered list of items that have been selected. If the user clicks on one of them, then we'll remove the selection. We can remove items with the \nRemove\n query that we wrote a little earlier.\n\n\nBut wait! Since this is rendering inside of \nSelect\n, it needs to have the \nSelect\n type signature. If we try to write this function it will fail:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n-- The items that have already been selected and can be removed\n\n\nrenderSelections\n \n::\n \nSelect\n.\nComponentHTML\n \nQuery\n \nString\n \n(\nEffects\n \neff\n)\n\n\nrenderSelections\n \n=\n\n  \nHH\n.\nul_\n\n  \n(\n \nst\n.\nselections\n \n#\n\n      \n(\n\\\nitem\n \n-\n\n        \nHH\n.\nli\n\n        \n[\n \nHE\n.\nonClick\n \n$\n \nHE\n.\ninput_\n \n$\n \nRemove\n \nitem\n \n]\n\n        \n[\n \nHH\n.\ntext\n \nitem\n \n]\n\n      \n)\n\n  \n)\n\n\n\n\n\n\n\nThe compiler gives us this error:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nError\n \nfound\n \nin\n \nmodule\n \nComponent\n\n\n  \nCould\n \nnot\n \nmatch\n \ntype\n\n\n    \nFree\n \n(\nQueryF\n \nt2\n \nt3\n \nt4\n)\n\n\n  \nwith\n \ntype\n\n\n    \nQuery\n\n\n\nwhile\n \ntrying\n \nto\n \nmatch\n \ntype\n \nFree\n \n(\nQueryF\n \nt2\n \nt3\n \nt4\n)\n \nUnit\n\n  \nwith\n \ntype\n \nQuery\n \nUnit\n\n\n\n\n\n\n\nThe problem is that we're using a parent query in the body of a render function for a component with an entirely different query algebra. If we tried to run this in \nSelect\n it would have no idea what to do with the \n!#hs Remove\n query! Instead, we need to \nembed\n this query.\n\n\nTo embed a parent query into \nSelect\n, we'll use a query from \nSelect\n called \nRaise\n and a message called \nEmit\n.\n\n\nWe've already seen \nEmit\n before -- when we receive this message, we simply evaluate the query within it. That's how we can evaluate queries like \nRemove\n in the parent component even though the event actually happened inside its child, the \nSelect\n component.\n\n\nRaise\n is a new one: this query exists to wrap parent queries so they can be embedded. That's why \nSelect\n carries around your parent query in its type signature everywhere!\n\n\nAs a rule of thumb, any time you need to extend functionality in \nSelect\n, you will:\n\n\n\n\nWrite the new functionality as a query in your parent component and accompanying \neval\n handler. This handler can freely trigger queries and updates in \nSelect\n, or modify parent state that is then used in the \nSelect\n render function. This is quite powerful!\n\n\nEnsure that you are handling output messages from \nSelect\n, and specifically that when you receive the \nEmit\n message that you recursively evaluate it as was demonstrated earlier in the tutorial.\n\n\nPlace the query in \nSelect\n's render function wrapped in \nSelect\n.\nraise\n, triggered by whatever event you would like.\n\n\n\n\nLet's see all of this in action:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nrenderSelections\n \n=\n\n  \nHH\n.\nul_\n\n  \n(\n \nst\n.\nselections\n \n#\n\n      \n(\n\\\nitem\n \n-\n\n        \nHH\n.\nli\n\n        \n[\n \nHE\n.\nonClick\n \n$\n \nSelect\n.\nalways\n \n$\n \nSelect\n.\nraise\n \n$\n \nRemove\n \nitem\n \nunit\n \n]\n\n        \n[\n \nHH\n.\ntext\n \nitem\n \n]\n\n      \n)\n\n  \n)\n\n\n\n\n\n\n\nNow we can use this inside \nSelect\n and it will behave just as if it had been written in the parent all along!\n\n\nLet's move on to the input field. This field needs to be controlled by \nSelect\n and must have the \nsetInputProps\n helper used on its array of properties:\n\n\n1\n2\n-- The text input field that will capture key events\n\n\nrenderInput\n \n=\n \nHH\n.\ninput\n \n(\n \nSetters\n.\nsetInputProps\n \n[]\n \n)\n\n\n\n\n\n\n\nThat's it! Now we have all the key events wired up for you. You could embed your own queries here, or add CSS, or whatever you want and the behavior will still work just fine.\n\n\n\n\nWarning\n\n\nSelect\n will append the properties it needs to the input field, including \nonMouseDown\n, \nonValueInput\n, and so on. Unfortunately there can only be one of these handlers in the list of properties, so if you already placed an \nonValueInput\n handler it will be overwritten by \nSelect\n. If you need to trigger some new functionality from the same handler that \nSelect\n is using, then you can always write a custom \nsetInputProps\n function for yourself that routes the event to your own query \nand\n the relevant \nSelect\n query. Take a look at the module documentation for \nSelect.Utils.Setters\n to see how.\n\n\n\n\nNext, let's render the actual items. Remember that we need to use \nsetContainerProps\n on the containing element (in this case \nHH\n.\nul\n) and \nsetItemProps\n on each item.\n\n\nThis code is a little trickier. We only want to show the items when the user has focused the typeahead and hide them otherwise. If there are no items, then we want to embed a \"Refresh Data\" button with some custom functionality. And we want to use \nSelect\n's information about which item is highlighted to apply a little CSS.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n-- The parent element holding the items\n\n\nrenderContainer\n \n=\n \ncase\n \nchildState\n.\nvisibility\n \nof\n\n  \nSelect\n.\nOff\n \n-\n \nHH\n.\ntext\n \n\n  \nSelect\n.\nOn\n \n-\n\n    \nHH\n.\nul\n\n    \n(\n \nSetters\n.\nsetContainerProps\n \n[]\n \n)\n\n    \n(\n \ncase\n \nnull\n \nchildState\n.\nitems\n \nof\n\n        \ntrue\n \n-\n\n          \nmapWithIndex\n \nrenderItem\n \nchildState\n.\nitems\n\n        \n_\n \n-\n\n          \n[\n \nHH\n.\nli\n\n            \n[\n \nHE\n.\nonClick\n\n              \n$\n \nSelect\n.\nalways\n\n              \n$\n \nSelect\n.\nraise\n\n              \n$\n \nH\n.\naction\n\n              \n$\n \nHandleSelect\n \n(\nSelect\n.\nSearched\n \n)\n\n            \n]\n\n            \n[\n \nHH\n.\ntext\n \nFetch data again.\n \n]\n\n          \n]\n\n    \n)\n\n\n\n-- Each individual item, which will receive an index and the item\n\n\nrenderItem\n \nix\n \nitem\n \n=\n\n  \nHH\n.\nli\n\n  \n(\n \nSetters\n.\nsetItemProps\n \nix\n\n      \n-- If this is the highlighted item, then apply CSS\n\n    \n$\n \ncase\n \nJust\n \nix\n \n==\n \nchildState\n.\nhighlightedIndex\n \nof\n\n        \ntrue\n \n-\n \n[\n \nHP\n.\nattr\n \n(\nHH\n.\nAttrName\n \nstyle\n)\n \ncolor: red;\n \n]\n\n        \n_\n \n-\n \n[]\n\n  \n)\n\n  \n[\n \nHH\n.\ntext\n \nitem\n \n]\n\n\n\n\n\n\n\nTo recap, we'll use these helper functions in the overall render function we're passing to \nSelect\n:\n\n\n1\n2\n3\n4\n5\n6\n7\ntypeahead\n \nparentState\n \nchildState\n \n=\n\n  \nHH\n.\ndiv_\n\n  \n[\n \nrenderSelections\n,\n \nrenderInput\n,\n \nrenderContainer\n \n]\n\n  \nwhere\n\n    \nrenderSelections\n \n=\n \n...\n\n    \nrenderInput\n \n=\n \n...\n\n    \nrenderContainer\n \n=\n \n...\n\n\n\n\n\n\n\nIf you got a little lost in all the rendering code here, don't worry: the full code is contained at the end of the tutorial.\n\n\nConclusion\n\n\nThat's it! We now have a fully-functioning typeahead that will fetch data remotely after debouncing a user's search, and if there are no results, will allow the user to refresh the data. Notably, several parts of this typeahead are not supported in any way by \nSelect\n, but we've been able to freely extend the component to make this possible.\n\n\nNext Steps\n\n\nNow that you're able to build a typeahead with \nSelect\n you know everything you need to build more complex components like date pickers and image pickers. The next tutorial in the series, \nLet's build a date picker\n, is currently a work in progress.\n\n\n\n\nTip\n\n\nDid you notice anything you would improve about this tutorial or the \nSelect\n library? I'd love to hear about it! Feel free to reach out on the \nfunctional programming Slack\n or on the \nPureScript user forum\n. If you found a bug or would like to make an improvement, please open an issue or pull request on the library.\n\n\n\n\nSource Code\n\n\nIf you'd like to use this component as a starting point from which to build your own, feel free to copy/paste the source code below.\n\n\nFull source code for the tutorial\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\nmodule\n \nComponent\n \nwhere\n\n\n\nimport\n \nPrelude\n\n\n\nimport\n \nControl.Monad.Aff\n \n(\nAff\n)\n\n\nimport\n \nControl.Monad.Aff.AVar\n \n(\nAVAR\n)\n\n\nimport\n \nControl.Monad.Aff.Class\n \n(\nclass\n \nMonadAff\n)\n\n\nimport\n \nDOM\n \n(\nDOM\n)\n\n\nimport\n \nData.Argonaut\n \n(\nJson\n,\n \ndecodeJson\n,\n \n(\n.?\n))\n\n\nimport\n \nData.Array\n \n(\ndifference\n,\n \nfilter\n,\n \nmapWithIndex\n,\n \nnull\n,\n \n(\n:\n))\n\n\nimport\n \nData.Either\n \n(\nEither\n)\n\n\nimport\n \nData.Maybe\n \n(\nMaybe\n(\n..\n))\n\n\nimport\n \nData.Time.Duration\n \n(\nMilliseconds\n(\n..\n))\n\n\nimport\n \nData.Traversable\n \n(\ntraverse\n)\n\n\nimport\n \nHalogen\n \nas\n \nH\n\n\nimport\n \nHalogen.HTML\n \nas\n \nHH\n\n\nimport\n \nHalogen.HTML.Events\n \nas\n \nHE\n\n\nimport\n \nHalogen.HTML.Properties\n \n(\nattr\n)\n \nas\n \nHP\n\n\nimport\n \nNetwork.HTTP.Affjax\n \n(\nAJAX\n,\n \nget\n)\n\n\nimport\n \nNetwork.RemoteData\n \n(\nRemoteData\n(\n..\n),\n \nfromEither\n,\n \nwithDefault\n)\n\n\nimport\n \nSelect\n \nas\n \nSelect\n\n\nimport\n \nSelect.Utils.Setters\n \nas\n \nSetters\n\n\n\ndata\n \nQuery\n \na\n\n  \n=\n \nHandleSelect\n \n(\nSelect\n.\nMessage\n \nQuery\n \nString\n)\n \na\n\n  \n|\n \nRemove\n \nString\n \na\n\n\n\ntype\n \nState\n \n=\n\n  \n{\n \nitems\n \n::\n \nRemoteData\n \nString\n \n(\nArray\n \nString\n)\n\n  \n,\n \nselections\n \n::\n \nArray\n \nString\n\n  \n}\n\n\n\ntype\n \nInput\n \n=\n \nUnit\n\n\n\ntype\n \nMessage\n \n=\n \nVoid\n\n\n\ntype\n \nChildSlot\n \n=\n \nUnit\n\n\ntype\n \nChildQuery\n \neff\n \n=\n \nSelect\n.\nQuery\n \nQuery\n \nString\n \neff\n\n\n\ntype\n \nEffects\n \neff\n \n=\n\n  \n(\n \navar\n \n::\n \nAVAR\n\n  \n,\n \ndom\n \n::\n \nDOM\n\n  \n,\n \najax\n \n::\n \nAJAX\n\n  \n|\n \neff\n\n  \n)\n\n\n\ncomponent\n \n::\n \n\u2200\n \neff\n \nm\n\n  \n.\n \nMonadAff\n \n(\nEffects\n \neff\n)\n \nm\n\n \n=\n \nH\n.\nComponent\n \nHH\n.\nHTML\n \nQuery\n \nInput\n \nMessage\n \nm\n\n\ncomponent\n \n=\n\n  \nH\n.\nparentComponent\n\n    \n{\n \ninitialState\n\n    \n,\n \nrender\n\n    \n,\n \neval\n\n    \n,\n \nreceiver\n:\n \nconst\n \nNothing\n\n    \n}\n\n  \nwhere\n\n\n  \ninitialState\n \n::\n \nInput\n \n-\n \nState\n\n  \ninitialState\n \n=\n \nconst\n\n    \n{\n \nitems\n:\n \nNotAsked\n\n    \n,\n \nselections\n:\n \n[]\n\n    \n}\n\n\n  \nfetchItems\n \n::\n \nString\n \n-\n \nAff\n \n(\nEffects\n \neff\n)\n \n(\nEither\n \nString\n \n(\nArray\n \nString\n))\n\n  \nfetchItems\n \nstr\n \n=\n \ndo\n\n     \n(\nres\n \n::\n \nJson\n)\n \n-\n \n_\n.\nresponse\n\n       \n$\n \nget\n \n(\nhttps://swapi.co/api/people/?search=\n \n \nstr\n)\n\n\n     \npure\n \n$\n \ndo\n\n       \nobj\n \n-\n \ndecodeJson\n \nres\n\n       \narr\n \n-\n \nobj\n \n.?\n \nresults\n\n       \ntraverse\n \n(\ndecodeJson\n \n=\n \nflip\n \n(\n.?\n)\n \nname\n)\n \narr\n\n\n  \nrender\n \n::\n \nState\n \n-\n \nH\n.\nParentHTML\n \nQuery\n \n(\nChildQuery\n \n(\nEffects\n \neff\n))\n \nChildSlot\n \nm\n\n  \nrender\n \nst\n \n=\n\n    \nHH\n.\ndiv_\n\n    \n[\n \nHH\n.\nslot\n \nunit\n \nSelect\n.\ncomponent\n \nselectInput\n \n(\nHE\n.\ninput\n \nHandleSelect\n)\n \n]\n\n\n    \nwhere\n\n\n    \nselectInput\n \n::\n \nSelect\n.\nInput\n \nQuery\n \nString\n \n(\nEffects\n \neff\n)\n\n    \nselectInput\n \n=\n\n      \n{\n \ninputType\n:\n \nSelect\n.\nTextInput\n\n      \n,\n \nitems\n:\n \n[]\n\n      \n,\n \ninitialSearch\n:\n \nNothing\n\n      \n,\n \ndebounceTime\n:\n \nJust\n \n$\n \nMilliseconds\n \n250.0\n\n      \n,\n \nrender\n:\n \ntypeahead\n \nst\n\n      \n}\n\n\n    \ntypeahead\n\n      \n::\n \nState\n\n      \n-\n \nSelect\n.\nState\n \nString\n \n(\nEffects\n \neff\n)\n\n      \n-\n \nSelect\n.\nComponentHTML\n \nQuery\n \nString\n \n(\nEffects\n \neff\n)\n\n    \ntypeahead\n \nparentState\n \nchildState\n \n=\n\n      \nHH\n.\ndiv_\n\n      \n[\n \nrenderSelections\n,\n \nrenderInput\n,\n \nrenderContainer\n \n]\n\n      \nwhere\n\n        \n-- The items that have already been selected and can be removed\n\n        \nrenderSelections\n \n=\n\n          \nHH\n.\nul_\n\n          \n(\n \nst\n.\nselections\n \n#\n\n              \n(\n\\\nitem\n \n-\n\n                \nHH\n.\nli\n\n                \n[\n \nHE\n.\nonClick\n \n$\n \nSelect\n.\nalways\n \n$\n \nSelect\n.\nraise\n \n$\n \nRemove\n \nitem\n \nunit\n \n]\n\n                \n[\n \nHH\n.\ntext\n \nitem\n \n]\n\n              \n)\n\n          \n)\n\n\n        \n-- The text input field that will capture key events\n\n        \nrenderInput\n \n=\n \nHH\n.\ninput\n \n(\n \nSetters\n.\nsetInputProps\n \n[]\n \n)\n\n\n        \n-- The parent element holding the items  container\n\n        \nrenderContainer\n \n=\n \ncase\n \nchildState\n.\nvisibility\n \nof\n\n          \nSelect\n.\nOff\n \n-\n \nHH\n.\ntext\n \n\n          \nSelect\n.\nOn\n \n-\n\n            \nHH\n.\nul\n\n            \n(\n \nSetters\n.\nsetContainerProps\n \n[]\n \n)\n\n            \n(\n \ncase\n \nnull\n \nchildState\n.\nitems\n \nof\n\n                \ntrue\n \n-\n\n                  \nmapWithIndex\n \nrenderItem\n \nchildState\n.\nitems\n\n                \n_\n \n-\n\n                  \n[\n \nHH\n.\nli\n\n                    \n[\n \nHE\n.\nonClick\n\n                      \n$\n \nSelect\n.\nalways\n\n                      \n$\n \nSelect\n.\nraise\n\n                      \n$\n \nHandleSelect\n \n(\nSelect\n.\nSearched\n \n)\n \nunit\n\n                    \n]\n\n                    \n[\n \nHH\n.\ntext\n \nFetch data again.\n \n]\n\n                  \n]\n\n            \n)\n\n\n        \n-- Each individual item, which will receive an index and the item\n\n        \nrenderItem\n \nix\n \nitem\n \n=\n\n          \nHH\n.\nli\n\n          \n(\n \nSetters\n.\nsetItemProps\n \nix\n\n            \n-- If this is the highlighted item, then apply CSS\n\n            \n$\n \ncase\n \nJust\n \nix\n \n==\n \nchildState\n.\nhighlightedIndex\n \nof\n\n                \ntrue\n \n-\n \n[\n \nHP\n.\nattr\n \n(\nHH\n.\nAttrName\n \nstyle\n)\n \ncolor: red;\n \n]\n\n                \n_\n \n-\n \n[]\n\n          \n)\n\n          \n[\n \nHH\n.\ntext\n \nitem\n \n]\n\n\n\n  \neval\n \n::\n \nQuery\n \n~\n \nH\n.\nParentDSL\n \nState\n \nQuery\n \n(\nChildQuery\n \n(\nEffects\n \neff\n))\n \nChildSlot\n \nMessage\n \nm\n\n  \neval\n \n=\n \ncase\n \n_\n \nof\n\n    \nRemove\n \nitem\n \nnext\n \n-\n \ndo\n\n      \nH\n.\nmodify\n \n\\\nst\n \n-\n \nst\n \n{\n \nselections\n \n=\n \nfilter\n \n(\n_\n \n/=\n \nitem\n)\n \nst\n.\nselections\n \n}\n\n      \nst\n \n-\n \nH\n.\nget\n\n      \n_\n \n-\n \nH\n.\nquery\n \nunit\n\n        \n$\n \nSelect\n.\nreplaceItems\n\n        \n$\n \ndifference\n \n(\nwithDefault\n \n[]\n \nst\n.\nitems\n)\n \nst\n.\nselections\n\n      \npure\n \nnext\n\n\n    \nHandleSelect\n \nmessage\n \nnext\n \n-\n \ncase\n \nmessage\n \nof\n\n      \nSelect\n.\nSearched\n \nstring\n \n-\n \ndo\n\n        \nH\n.\nmodify\n \n_\n \n{\n \nitems\n \n=\n \nLoading\n \n}\n\n        \n_\n \n-\n \nH\n.\nquery\n \nunit\n \n$\n \nSelect\n.\nreplaceItems\n \n[]\n\n        \nnewItems\n \n-\n \nH\n.\nliftAff\n \n(\nfetchItems\n \nstring\n)\n\n        \nH\n.\nmodify\n \n_\n \n{\n \nitems\n \n=\n \nfromEither\n \nnewItems\n \n}\n\n\n        \nst\n \n-\n \nH\n.\nget\n\n        \n_\n \n-\n \nH\n.\nquery\n \nunit\n\n          \n$\n \nSelect\n.\nreplaceItems\n\n          \n$\n \ndifference\n \n(\nwithDefault\n \n[]\n \nst\n.\nitems\n)\n \nst\n.\nselections\n\n\n        \npure\n \nnext\n\n\n      \nSelect\n.\nSelected\n \nitem\n \n-\n \ndo\n\n        \nH\n.\nmodify\n \n\\\nst\n \n-\n \nst\n \n{\n \nselections\n \n=\n \nitem\n \n:\n \nst\n.\nselections\n \n}\n\n        \nst\n \n-\n \nH\n.\nget\n\n        \n_\n \n-\n \nH\n.\nquery\n \nunit\n\n          \n$\n \nSelect\n.\nreplaceItems\n\n          \n$\n \ndifference\n \n(\nwithDefault\n \n[]\n \nst\n.\nitems\n)\n \nst\n.\nselections\n\n        \npure\n \nnext\n\n\n      \nSelect\n.\nVisibilityChanged\n \nvis\n \n-\n\n        \npure\n \nnext\n\n\n      \nSelect\n.\nEmit\n \nquery\n \n-\n \ndo\n\n        \neval\n \nquery\n\n        \npure\n \nnext",
            "title": "Build a typeahead"
        },
        {
            "location": "/tutorials/typeahead/#lets-build-a-typeahead-in-purescript",
            "text": "Typeaheads are among the most common selection components you'll build. Most web developers have had to implement at least one of these before and they can be surprisingly difficult to build. Luckily, with  Select , implementing a typeahead that fits your custom design takes little more than writing the rendering code and then tweaking it with a helper function or two.  In this tutorial we'll build a typeahead with the following features:   Users can search Star Wars characters by name; their searches will be debounced automatically and results will be fetched asynchronously.  The typeahead should support keyboard-only use: arrow keys should step up and down the items, Enter should select, Escape should close, and so on.  The typeahead should manage its own selections, including insertion and removal, and should notify its parent when the selections have changed.  If a search returns no results, then there should be an embedded \"fetch data\" button the user can click to force a request with an empty search. It should display within the list of items.   Along the way, we'll see how to extend  Select 's features by embedding parent queries (we'll use this to embed the \"fetch data\" button in the list).   Info  This tutorial assumes you've followed the steps in the  Project Setup  section. While not necessary, this code is tested with those steps in mind.  It also assumes familiarity with Halogen and intermediate PureScript experience or that you have already completed the  more thorough, beginner-friendly dropdown tutorial . If you need a Halogen refresher, try the official  Halogen guide  or the  whirlwind tour  of our starter component.  Your code should work at the end of every step. If you run into issues or your code doesn't compile, please come visit us on the  PureScript user forum  or the  #fpchat Slack channel .",
            "title": "Let's Build a Typeahead in PureScript!"
        },
        {
            "location": "/tutorials/typeahead/#basic-setup",
            "text": "In this tutorial, we'll build a typeahead component from scratch. You can either follow along using the minimal component from the  Project Setup section  or start your own.  If you didn't follow the project setup, grab the source for our starting component here:  Source code for a minimal starting component  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42 module   Component   where  import   Prelude  import   Control.Monad.Aff.Class   ( class   MonadAff )  import   Data.Const   ( Const )  import   Data.Maybe   ( Maybe ( .. ))  import   Halogen   as   H  import   Halogen.HTML   as   HH  data   Query   a \n   =   NoOp   a  type   State   =   Unit  type   Input   =   Unit  type   Message   =   Void  type   ChildSlot   =   Unit  type   ChildQuery   =   Const   Void  component   ::   \u2200   eff   m \n   .   MonadAff   eff   m \n  =   H . Component   HH . HTML   Query   Input   Message   m  component   = \n   H . parentComponent \n     {   initialState \n     ,   render \n     ,   eval \n     ,   receiver :   const   Nothing \n     } \n   where \n\n   initialState   ::   Input   -   State \n   initialState   =   const   unit \n\n   render   ::   State   -   H . ParentHTML   Query   ChildQuery   ChildSlot   m \n   render   st   =   HH . div_   [] \n\n   eval   ::   Query   ~   H . ParentDSL   State   Query   ChildQuery   ChildSlot   Message   m \n   eval   =   case   _   of \n     NoOp   next   -   pure   next",
            "title": "Basic Setup"
        },
        {
            "location": "/tutorials/typeahead/#install-dependencies",
            "text": "The first thing we'll do is make sure we have the libraries we need installed. Our typeahead is going to make API calls on our behalf, decode the response, and keep track of the state of requests using a special  RemoteData  data type. Let's go ahead and install our dependencies:  1\n2\n3\n4\n5\n6\n7\n8 # These should already be installed as part of the project setup \nbower i --save purescript-halogen purescript-halogen-select purescript-affjax # These are new dependencies \nbower i --save purescript-argonaut purescript-remotedata # Let s compile the new dependencies to ensure they re available to import \nyarn build",
            "title": "Install dependencies"
        },
        {
            "location": "/tutorials/typeahead/#integrate-the-component",
            "text": "Now let's make sure we have  Select  ready to go in our component. Import the library:  1\n2 import   Select   as   Select  import   Select.Utils.Setters   as   Setters    Next, since  Select  is going to be a child component, we'll need to update several types and functions. We will:   Delete the unnecessary  NoOp  query and relevant case in  eval  Add a new query to handle messages emitted by  Select  Update our  ChildQuery  type synonym to contain  Select 's query type  Update the type signatures for  eval  and  render  with the new  ChildQuery  Add a new case to  eval  for our new  HandleSelect  query    Tip  This tutorial doesn't explain things like child queries, slots, inputs, rendering,  Free ,  eval  functions, or other crucial Halogen knowledge. If you feel lost, I'd recommend checking out the  dropdown tutorial  before continuing.   Of course, we won't be prepared to handle messages or use  Select 's queries without knowing what they are. Let's start with the query type for the  Select  component,  QueryF :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18 -- | - `o`: The query type of the component that will mount this component in a child slot.  -- |        This allows you to embed your own queries into the `Select` component.  -- | - `item`: Your custom item type. It can be a simple type like `String`, or something  -- |           complex like `CalendarItem StartDate EndDate (Maybe Disabled)`.  -- | - `eff`: The component s effects.  data   QueryF   o   item   eff   a \n   =   Search   String   a \n   |   Highlight   Target   a \n   |   Select   Int   a \n   |   CaptureRef   ET . Event   a \n   |   Focus   Boolean   a \n   |   Key   KE . KeyboardEvent   a \n   |   PreventClick   ME . MouseEvent   a \n   |   SetVisibility   Visibility   a \n   |   GetVisibility   ( Visibility   -   a ) \n   |   ReplaceItems   ( Array   item )   a \n   |   Raise   ( o   Unit )   a \n   |   Receive   ( Input   o   item   eff )   a    Already we're faced with an interesting decision: how should we fill in the type variables that  Select  expects? Two of them are straightforward:   o  represents the type of queries that can be embedded in the component. You should fill this in with your parent component's query type. If you follow Halogen convention and name your type  Query , then filling this variable in will produce  Select . Query   Query   item   eff . If you take a look at where this variable is used, you'll see it shows up in the  Select  component's  Raise  and  Receive  queries. The  Raise  query is a wrapper that you can use to embed your query into the render function you provide to the component. The  Receive  query leverages  Select 's  Input  type, which includes that render function. I'll have a lot more to say about embedding your own query type into  Select  later on.  eff  is the effect row that the  Select  component is going to use. The component uses  DOM  and  AVAR  effects.  eff  is required for the  State  type, which is itself in the type for the render function, which is itself passed to  Select  via the component's  Input  type, which is handled with the  Receive  query, and so you'll see the type variable present in all the key component types.   The second type argument is more interesting.  Select  allows you to provide any type as your selectable \"item\". While in this tutorial we're going to stick with strings you could very well make a significantly more information-rich type.  Writing useful item types Any time you need to render some items differently than others, or you need different logic for when one item is selected vs. another, you should encode that information in the item type. For example, at CitizenNet, our calendar component has an item type like this: 1 data   CalendarItem   =   CalendarItem   SelectedStatus   DisabledStatus   Boundary   Range   Date    These custom types give us everything we need to know to render various dates and handle them when selected. For example, if you want some items to be selectable and others to be disabled, you could create an item type like this: 1\n2\n3\n4\n5\n6 data   Item   =   Selectable   String   |   Disabled   String  renderItem   ix   ( Selectable   str ) \n   =   HH . li   (   Setters . setItemProps   ix   [   ]   )   [   HH . text   str   ]  renderItem   _   ( Disabled   str ) \n   =   HH . li_    [   HH . text   str   ]    With all this information in mind, let's go ahead and make those changes:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 data   Query   a \n   =   HandleSelect   ( Select . Message   Query   String )   a  type   ChildSlot   =   Unit  type   ChildQuery   eff   =   Select . Query   Query   String   eff  component   = \n   ... \n   render   ::   State   -   H . ParentHTML   Query   ( ChildQuery   eff )   ChildSlot   m \n   render   st   =   HH . div_   [] \n\n   eval   ::   Query   ~   H . ParentDSL   State   Query   ( ChildQuery   eff )   ChildSlot   Message   m \n   eval   =   case   _   of \n     -- We ll just stub this out for the time being. \n     HandleSelect   message   next   -   pure   next    Next, we'll actually mount the  Select  component. We have everything except for the component's  Input  type so far, so we'll fill that in and leave the input as a type hole.  1\n2\n3\n4\n5\n6 import   Halogen.HTML.Events   as   HE  render   ::   State   -   H . ParentHTML   Query   ( ChildQuery   eff )   ChildSlot   m  render   st   = \n     HH . div_ \n     [   HH . slot   unit   Select . component   ? input   ( HE . input   HandleSelect )   ]    Right away we get a type error:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24 Error   found   in   module   Component \n\n   Could   not   match   type \n\n         (   avar   ::   AVAR \n         ,   dom   ::   DOM \n         |   t2 \n         ) \n\n     with   type \n\n         eff0  while   trying   to   match   type \n\n     QueryF   Query   String \n         (   avar   ::   AVAR \n         ,   dom   ::   DOM \n         |   t2 \n         ) \n\n     with   type   QueryF   Query   String   eff0  in   value   declaration   component    It's an easy fix: we've stated that our component can use any row of effects, but  Select  requires at least  AVAR  and  DOM . The component uses  AVAR  in order to implement debouncing, and since it manipulates the DOM, it needs the relevant effect. We need to add these effects to the parent component, too. We already know our component is going to make API calls on our behalf, so we'll add the  AJAX  effect as well.  Once we've created our  Effects  type, we'll need to apply it to every function that uses the  eff  variable (but not to type synonyms).  Why apply  Effects  to function signatures, not type synonyms? Effect rows can be surprisingly finicky to get right, especially when you have multiple levels of components and your code becomes more complex. Type synonyms help make your functions more readable by hiding unnecessary details, but in the case of effect rows, they tend to make it much more difficult to debug issues when two rows that are meant to unify don't. At CitizenNet, we follow a rule of thumb to always apply effects in function signatures, but not in type synonyms. That's why, as a general rule, you won't see this in our code: 1 type   ChildQuery   eff   =   Select . Query   Query   String   ( Effects   eff )     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 import   Control.Monad.Aff.AVar   ( AVAR )  import   DOM   ( DOM )  import   Network.HTTP.Affjax   ( AJAX )  type   Effects   eff   = \n   (   avar   ::   AVAR \n   ,   dom   ::   DOM \n   ,   ajax   ::   AJAX \n   |   eff \n   )  component   ::   \u2200   eff   m \n   .   MonadAff   ( Effects   eff )   m \n  =   H . Component   HH . HTML   Query   Input   Message   m \n\n   render   ::   State   -   H . ParentHTML   Query   ( ChildQuery   ( Effects   eff ))   ChildSlot   m \n   eval   ::   Query   ~   H . ParentDSL   State   Query   ( ChildQuery   ( Effects   eff ))   ChildSlot   Message   m    With that out of the way, we can turn to the component's input type. Here's what we're required to fill in, as per the  Select  module documentation :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 -- | Text-driven inputs will operate like a normal search-driven selection component.  -- | Toggle-driven inputs will capture key streams and debounce in reverse (only notify  -- | about searches when time has expired).  data   InputType \n   =   TextInput \n   |   Toggle  -- | The component s input type, which includes the component s render function. This  -- | render function can also be used to share data with the parent component, as every  -- | time the parent re-renders, the render function will refresh in `Select`.  type   Input   o   item   eff   = \n   {   inputType       ::   InputType \n   ,   items           ::   Array   item \n   ,   initialSearch   ::   Maybe   String \n   ,   debounceTime    ::   Maybe   Milliseconds \n   ,   render          ::   State   item   eff   -   ComponentHTML   o   item   eff \n   }    Let's look at these one-by-one:   We're using an input field in the DOM, so we'll use the  TextInput  type to drive the component.  We don't have any items yet (they'll be fetched via the Star Wars API), so we'll provide an empty array.  We don't want there to be an initial search; we'll wait for the user to type something. However, if at any point we want to fill in text in the input field (for example, set the text to the full selection when the user selects something), we can use this field to accomplish that.  We're making API calls every time the user performs a search, so we'll set a reasonable debounce time of a few hundred milliseconds.  Ah, the big issue: we need to write a render function and pass it in to the component. We don't have one yet, so we'll stub this out with a simple empty  div .   Let's write that input record now:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 import   Data.Time.Duration   ( Milliseconds ( .. ))  render   ::   State   -   H . ParentHTML   Query   ( ChildQuery   ( Effects   eff ))   ChildSlot   m  render   st   = \n   HH . div_ \n   [   HH . slot   unit   Select . component   selectInput   ( HE . input   HandleSelect )   ]  selectInput   ::   Select . Input   Query   String   ( Effects   eff )  selectInput   = \n   {   inputType :   Select . TextInput \n   ,   items :   [] \n   ,   initialSearch :   Nothing \n   ,   debounceTime :   Just   $   Milliseconds   250.0 \n   ,   render :   \\ _   -   HH . div_   [   HH . text   Not implemented   ] \n   }    All right! We've fully integrated the  Select  component. It's a little tedious to integrate the component the first time you do it, but it soon becomes second nature. At this point, we're ready to start writing our typeahead.   Now would be a good time to verify that this component is rendering properly. Compile the project and point your browser to  dist/index.html . You should see text rendering from within  Select .",
            "title": "Integrate the component"
        },
        {
            "location": "/tutorials/typeahead/#a-minimal-typeahead",
            "text": "Let's take a step back now that we have  Select  integrated. We are building a typeahead that will fetch some data asynchronously when the user makes a search. It needs to maintain a list of items that can be selected, and a list of items that have already been selected. The user should only be able to select any item once, so these two lists should have no shared items. We'd like the typeahead to handle all the data fetching and selections behind the scenes, and only notify the parent component when the selections have been updated.  With this information in mind, we can step through the key data types in our Halogen component and ensure they accurately capture the features we want.   Note  In the dropdown tutorial, we started by writing a render function and only later worried about state, queries, messages, and so on. However, I usually like to work in the other direction. We already know the behaviors and data we need to manage, and we don't need to render anything to implement them, though we'll certainly use our rendered component for testing.  Instead, we'll work through the major data types in our component and only once those are completed will we write some minimal rendering code. It might feel a little strange to spend so much time on data without once touching the HTML, but by the time we reach our rendering function it will naturally extend from the data.",
            "title": "A minimal typeahead"
        },
        {
            "location": "/tutorials/typeahead/#state",
            "text": "From our requirements, we know we'll need some information:   A list of items that can be selected by the user  A list of items that have already been selected, and which can be removed  The user's last search, so we can use it to fetch new data from the Star Wars API   It'll also be nice to have some extra information purely for rendering purposes, like:   An indicator as to whether the menu should be displayed or not  An indicator as to which item the user has focused, so we can highlight it   We have access to two distinct  State  types when we use  Select : the parent component state, which we own, and the  Select  component's state, which we can read and write. There's no point in duplicating information between the two if we can help it. But we have access to even more information: messages output by the component. Sometimes we can simply rely on the contents of these messages to take action without ever storing the result in state.  Let's take a quick look at what  Select  provides (take a look at the  module documentation  for more details):   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 type   State   item   eff   = \n   {   inputType          ::   InputType \n   ,   search             ::   String \n   ,   debounceTime       ::   Milliseconds \n   ,   debouncer          ::   Maybe   ( Debouncer   eff ) \n   ,   inputElement       ::   Maybe   HTMLElement \n   ,   items              ::   Array   item \n   ,   visibility         ::   Visibility \n   ,   highlightedIndex   ::   Maybe   Int \n   ,   lastIndex          ::   Int \n   }  data   Message   o   item \n   =   Searched   String \n   |   Selected   item \n   |   VisibilityChanged   Visibility \n   |   Emit   ( o   Unit )    It looks like we already have the list of selectable items stored in  Select , so we don't need that in our component state. We're fetching new items via an external API, so after each new search we can simply pass the new items straight down.  We also have the user's search stored in  State  and also raised as a message every time the debouncer runs out. We don't really care about every keystroke the user types, so we'll rely on the  Searched  message for this information.  We have our two pieces of rendering information, too, with the  visibility  and  highlightedIndex  fields.  In fact, it looks like the only thing we have to store in our  State  is the list of selecetions! That keeps things simple.  1 type   State   =   {   selections   ::   Array   String   }     Tip  Select  doesn't manage any selections on your behalf. What should happen when an item gets selected, after all? In some cases, you might want to stick it into a \"selected\" list and remove it from the list of available options. In others, you might want it to be selectable multiple times. Or you might want to just apply a highlight, like in a calendar picker. Rather than force you to fill out a configuration record,  Select  defers the decision to you.   This is OK, but I'd like some more information. We're fetching data asynchronously, right? That means that requests could possibly fail, or they might be in progress for a long time, or perhaps they might never get triggered in the first place. Ideally our typeahead could render differently depending on these states. If we don't keep track of our requests in  State , we won't have any of this information available for rendering.  It's the same idea as using an information-rich custom  item  type to add nuance to your rendering code. Luckily, there already exists a lovely package named  purescript-remotedata  that supplies us with a data type we can use to model each of these states:  1\n2\n3\n4\n5 data   RemoteData   e   a \n   =   NotAsked \n   |   Loading \n   |   Failure   e \n   |   Success   a    So while it's not strictly necessary to maintain a list of items in our state, we'll leverage  RemoteData  to have a more useful state type.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 type   State   = \n   {   items   ::   RemoteData   String   ( Array   String ) \n   ,   selections   ::   Array   String \n   }  initialState   ::   Input   -   State  initialState   =   const \n   {   items :   NotAsked \n   ,   selections :   [] \n   }",
            "title": "State"
        },
        {
            "location": "/tutorials/typeahead/#query",
            "text": "Now that we've got a usable  State  type, let's turn to our queries. Queries are the computations available to the component, so they're the place where we ought to think about what the typeahead should  do , rather than just how it should render.  Just like  State , when we write our own  Query  type on top of  Select , we should consider what is already available in the component. As usual, we'll turn to the  module documentation  to look at our available queries. I'd recommend scrolling through the available functions to get a glimpse of what  Select  offers, but we'll skip to the main points here.  Select  is going to manage all the keyboard events, text input, debouncing, moving the highlighted index, and so on. On top of that, we'll need to add some extra functionality: the ability to remove items that have already been selected, and the ability to fetch new items when the user performs a search. We'll at least need two queries to handle these two features.  Luckily, though, we already  have  a query available for when a new search has been performed: our  HandleSelect  query tied to the  Select . Searched  message! That means we really only need one new query:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18 data   Query   a \n   =   HandleSelect   ( Select . Message   Query   String )   a \n   |   Remove   String   a  eval   ::   Query   ~   H . ParentDSL   State   Query   ( ChildQuery   ( Effects   eff ))   ChildSlot   Message   m  eval   =   case   _   of \n   HandleSelect   message   next   -   case   message   of \n     Select . Searched   str   - \n       pure   next \n     Select . Selected   item   - \n       pure   next \n     Select . VisibilityChanged   vis   - \n       pure   next \n     Select . Emit   query   - \n       pure   next \n\n   Remove   item   next   - \n     pure   next    What do we want to happen in each of these queries? Let's work from the bottom to the top.",
            "title": "Query"
        },
        {
            "location": "/tutorials/typeahead/#remove",
            "text": "When the user clicks on an item that is already selected, we want to remove it from the selected list. We also want to re-insert it into the available items in  Select . It's easy enough to accomplish this:  1\n2\n3\n4\n5\n6\n7 Remove   item   next   -   do \n   H . modify   \\ st   -   st   {   selections   =   filter   ( _   /=   item )   st . selections   } \n   st   -   H . get \n   _   -   H . query   unit \n     $   Select . replaceItems \n     $   difference   ( withDefault   []   st . items )   st . selections \n   pure   next",
            "title": "Remove"
        },
        {
            "location": "/tutorials/typeahead/#emit",
            "text": "What should we do when we get the  Emit  message? This is returning our own query to us so we can run it, so we can recursively call  eval  with the query. You'll use this pattern every time you implement a new component with  Select :  1 Select . Emit   query   -   eval   query   *   pure   next",
            "title": "Emit"
        },
        {
            "location": "/tutorials/typeahead/#visibilitychange",
            "text": "What about when the visibility changes? We don't actually care about this one, so we'll ignore it. It's useful for validation, if we were to implement that.",
            "title": "VisibilityChange"
        },
        {
            "location": "/tutorials/typeahead/#selected",
            "text": "What about when an item is selected? This one is like the inverse of our  Remove  query. We want to remove the item from the available items and add it to the list of selections.  1\n2\n3\n4\n5\n6\n7 Select . Selected   item   -   do \n   H . modify   \\ st   -   st   {   selections   =   item   :   st . selections   } \n   st   -   H . get \n   _   -   H . query   unit \n     $   Select . replaceItems \n     $   difference   ( withDefault   []   st . items )   st . selections \n   pure   next",
            "title": "Selected"
        },
        {
            "location": "/tutorials/typeahead/#searched",
            "text": "We can finally consider what to do when the user performs a search. We won't do any fancy filtering on our own; we're going to punt that responsibility to an external API. Still, now we have to write the code to fetch that data.  Our function will hit the Star Wars API, decode the result into an array of strings, and then return them. In the case of failure, we'll return an error message.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 import   Data.Argonaut   ( Json ,   decodeJson ,   ( .? ))  import   Network.HTTP.Affjax   ( AJAX ,   get )  fetchItems   ::   String   -   Aff   ( Effects   eff )   ( Either   String   ( Array   String ))  fetchItems   str   =   do \n   ( res   ::   Json )   -   _ . response \n     $   get   ( https://swapi.co/api/people/?search=     str ) \n\n   pure   $   do \n     obj   -   decodeJson   res \n     arr   -   obj   .?   results \n     traverse   ( decodeJson   =   flip   ( .? )   name )   arr    Now that we have this helper function, we can handle new searches that users perform. First, we'll put our typeahead into the  Loading  state to represent an ongoing request. Then, we'll empty out the old items in  Select  to avoid out-of-sync data. Then, we'll fetch and decode our items, convert the result from  Either  to  RemoteData , and finally set it on  State .  Once our new items have been set, we can use the result to update  Select  just like we did when we handled new selections or removals.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 Select . Searched   string   -   do \n   H . modify   _   {   items   =   Loading   } \n   _   -   H . query   unit   $   Select . replaceItems   [] \n   newItems   -   H . liftAff   ( fetchItems   string ) \n   H . modify   _   {   items   =   fromEither   newItems   } \n\n   st   -   H . get \n   _   -   H . query   unit \n     $   Select . replaceItems \n     $   difference   ( withDefault   []   st . items )   st . selections    That's it! Our typeahead has all the logic necessary to function as required. All that's left to do is actually write the render function.",
            "title": "Searched"
        },
        {
            "location": "/tutorials/typeahead/#rendering",
            "text": "We have all the state and behavior necessary to run a working typeahead. Now, let's write the render function.  When you write a render function for a  Select  component, keep in mind that the function is going to be run  by  the child component. You can see this right away from the type signature of the render function that  Select  expects:  1 myRenderFunction   ::   Select . State   item   eff   -   Select . ComponentHTML   o   item   eff    In our case, we've already specialized our parent query, item, and effects, so the type signature is actually this:  1\n2\n3 myRenderFunction \n   ::   Select . State   String   ( Effects   eff ) \n   -   Select . ComponentHTML   Query   String   ( Effects   eff )     Tip  When you write a component with  Select , you'll usually want access to the parent component's state and query algebra. This is what makes the pattern powerful: you can use any values from your state in the render function you provide to  Select , and you can embed any queries from your query algebra, too. Most of the time developers will stay in scope with the parent component by writing the  Select  render function within a  where  clause. However, you could also write a render function outside the parent component so long as it takes the parent state as an argument, like this:  1\n2\n3\n4 selectRenderFunction \n   ::   Parent . State \n   -   Select . State   String   ( Parent . Effects   eff ) \n   -   Select . ComponentHTML   Parent . Query   String   ( Parent . Effects   eff )    Then you can write this render function anywhere you'd like while retaining access to the parent's state and query algebra.  Select  will not accept this function as-is, however; you'll need to apply it to the parent state before sending the function in as input:  1 selectInput   =   {   ... ,   render :   selectRenderFunction   parentState ,   ...   }     Since you write the render function to pass to Select, you retain full control of the design and most of the structure of your HTML. All that  Select  expects from you is that you apply the three helper functions from  Setters :   setItemProps  on each item that can be selected  setContainerProps  on the parent HTML element of all the items  setInputProps  on the text input   For this reason, I usually break my component's render function into three helpers. Let's go ahead and write our render function for the typeahead.  Our overall function is going to take the parent state, the  Select  state, and output the  Select  component HTML type:  1\n2\n3\n4\n5 typeahead \n   ::   State \n   -   Select . State   String   ( Effects   eff ) \n   -   Select . ComponentHTML   Query   String   ( Effects   eff )  typeahead   parentState   childState   =   ...    Let's write this function from top to bottom. We want our typeahead to have the list of selected items above the input field, then the input field, then the list of available items (if there are any). Ultimately, with helper functions, we'd like to write this:  1\n2\n3\n4\n5 typeahead   parentState   childState   = \n   HH . div_ \n   [   renderSelections ,   renderInput ,   renderContainer   ] \n   where \n     ...    Let's start with the first one:  renderSelections . This function will leverage only the parent state, which contains the selections, and won't use anything from  Select .   Tip  In fact you don't need to render the selections inside  Select  at all -- you could render the selections first, and then mount the  Select  component below. We use this approach for our own typeaheads at CitizenNet. However, embedding the selections into the  Select  component allows me to show off how embedding parent queries works and it's an equally viable design, so that's the approach taken here.   We're just going to render an unordered list of items that have been selected. If the user clicks on one of them, then we'll remove the selection. We can remove items with the  Remove  query that we wrote a little earlier.  But wait! Since this is rendering inside of  Select , it needs to have the  Select  type signature. If we try to write this function it will fail:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 -- The items that have already been selected and can be removed  renderSelections   ::   Select . ComponentHTML   Query   String   ( Effects   eff )  renderSelections   = \n   HH . ul_ \n   (   st . selections   # \n       ( \\ item   - \n         HH . li \n         [   HE . onClick   $   HE . input_   $   Remove   item   ] \n         [   HH . text   item   ] \n       ) \n   )    The compiler gives us this error:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 Error   found   in   module   Component \n\n   Could   not   match   type \n\n     Free   ( QueryF   t2   t3   t4 ) \n\n   with   type \n\n     Query  while   trying   to   match   type   Free   ( QueryF   t2   t3   t4 )   Unit \n   with   type   Query   Unit    The problem is that we're using a parent query in the body of a render function for a component with an entirely different query algebra. If we tried to run this in  Select  it would have no idea what to do with the  !#hs Remove  query! Instead, we need to  embed  this query.  To embed a parent query into  Select , we'll use a query from  Select  called  Raise  and a message called  Emit .  We've already seen  Emit  before -- when we receive this message, we simply evaluate the query within it. That's how we can evaluate queries like  Remove  in the parent component even though the event actually happened inside its child, the  Select  component.  Raise  is a new one: this query exists to wrap parent queries so they can be embedded. That's why  Select  carries around your parent query in its type signature everywhere!  As a rule of thumb, any time you need to extend functionality in  Select , you will:   Write the new functionality as a query in your parent component and accompanying  eval  handler. This handler can freely trigger queries and updates in  Select , or modify parent state that is then used in the  Select  render function. This is quite powerful!  Ensure that you are handling output messages from  Select , and specifically that when you receive the  Emit  message that you recursively evaluate it as was demonstrated earlier in the tutorial.  Place the query in  Select 's render function wrapped in  Select . raise , triggered by whatever event you would like.   Let's see all of this in action:  1\n2\n3\n4\n5\n6\n7\n8\n9 renderSelections   = \n   HH . ul_ \n   (   st . selections   # \n       ( \\ item   - \n         HH . li \n         [   HE . onClick   $   Select . always   $   Select . raise   $   Remove   item   unit   ] \n         [   HH . text   item   ] \n       ) \n   )    Now we can use this inside  Select  and it will behave just as if it had been written in the parent all along!  Let's move on to the input field. This field needs to be controlled by  Select  and must have the  setInputProps  helper used on its array of properties:  1\n2 -- The text input field that will capture key events  renderInput   =   HH . input   (   Setters . setInputProps   []   )    That's it! Now we have all the key events wired up for you. You could embed your own queries here, or add CSS, or whatever you want and the behavior will still work just fine.   Warning  Select  will append the properties it needs to the input field, including  onMouseDown ,  onValueInput , and so on. Unfortunately there can only be one of these handlers in the list of properties, so if you already placed an  onValueInput  handler it will be overwritten by  Select . If you need to trigger some new functionality from the same handler that  Select  is using, then you can always write a custom  setInputProps  function for yourself that routes the event to your own query  and  the relevant  Select  query. Take a look at the module documentation for  Select.Utils.Setters  to see how.   Next, let's render the actual items. Remember that we need to use  setContainerProps  on the containing element (in this case  HH . ul ) and  setItemProps  on each item.  This code is a little trickier. We only want to show the items when the user has focused the typeahead and hide them otherwise. If there are no items, then we want to embed a \"Refresh Data\" button with some custom functionality. And we want to use  Select 's information about which item is highlighted to apply a little CSS.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31 -- The parent element holding the items  renderContainer   =   case   childState . visibility   of \n   Select . Off   -   HH . text   \n   Select . On   - \n     HH . ul \n     (   Setters . setContainerProps   []   ) \n     (   case   null   childState . items   of \n         true   - \n           mapWithIndex   renderItem   childState . items \n         _   - \n           [   HH . li \n             [   HE . onClick \n               $   Select . always \n               $   Select . raise \n               $   H . action \n               $   HandleSelect   ( Select . Searched   ) \n             ] \n             [   HH . text   Fetch data again.   ] \n           ] \n     )  -- Each individual item, which will receive an index and the item  renderItem   ix   item   = \n   HH . li \n   (   Setters . setItemProps   ix \n       -- If this is the highlighted item, then apply CSS \n     $   case   Just   ix   ==   childState . highlightedIndex   of \n         true   -   [   HP . attr   ( HH . AttrName   style )   color: red;   ] \n         _   -   [] \n   ) \n   [   HH . text   item   ]    To recap, we'll use these helper functions in the overall render function we're passing to  Select :  1\n2\n3\n4\n5\n6\n7 typeahead   parentState   childState   = \n   HH . div_ \n   [   renderSelections ,   renderInput ,   renderContainer   ] \n   where \n     renderSelections   =   ... \n     renderInput   =   ... \n     renderContainer   =   ...    If you got a little lost in all the rendering code here, don't worry: the full code is contained at the end of the tutorial.",
            "title": "Rendering"
        },
        {
            "location": "/tutorials/typeahead/#conclusion",
            "text": "That's it! We now have a fully-functioning typeahead that will fetch data remotely after debouncing a user's search, and if there are no results, will allow the user to refresh the data. Notably, several parts of this typeahead are not supported in any way by  Select , but we've been able to freely extend the component to make this possible.",
            "title": "Conclusion"
        },
        {
            "location": "/tutorials/typeahead/#next-steps",
            "text": "Now that you're able to build a typeahead with  Select  you know everything you need to build more complex components like date pickers and image pickers. The next tutorial in the series,  Let's build a date picker , is currently a work in progress.   Tip  Did you notice anything you would improve about this tutorial or the  Select  library? I'd love to hear about it! Feel free to reach out on the  functional programming Slack  or on the  PureScript user forum . If you found a bug or would like to make an improvement, please open an issue or pull request on the library.",
            "title": "Next Steps"
        },
        {
            "location": "/tutorials/typeahead/#source-code",
            "text": "If you'd like to use this component as a starting point from which to build your own, feel free to copy/paste the source code below.  Full source code for the tutorial   1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182 module   Component   where  import   Prelude  import   Control.Monad.Aff   ( Aff )  import   Control.Monad.Aff.AVar   ( AVAR )  import   Control.Monad.Aff.Class   ( class   MonadAff )  import   DOM   ( DOM )  import   Data.Argonaut   ( Json ,   decodeJson ,   ( .? ))  import   Data.Array   ( difference ,   filter ,   mapWithIndex ,   null ,   ( : ))  import   Data.Either   ( Either )  import   Data.Maybe   ( Maybe ( .. ))  import   Data.Time.Duration   ( Milliseconds ( .. ))  import   Data.Traversable   ( traverse )  import   Halogen   as   H  import   Halogen.HTML   as   HH  import   Halogen.HTML.Events   as   HE  import   Halogen.HTML.Properties   ( attr )   as   HP  import   Network.HTTP.Affjax   ( AJAX ,   get )  import   Network.RemoteData   ( RemoteData ( .. ),   fromEither ,   withDefault )  import   Select   as   Select  import   Select.Utils.Setters   as   Setters  data   Query   a \n   =   HandleSelect   ( Select . Message   Query   String )   a \n   |   Remove   String   a  type   State   = \n   {   items   ::   RemoteData   String   ( Array   String ) \n   ,   selections   ::   Array   String \n   }  type   Input   =   Unit  type   Message   =   Void  type   ChildSlot   =   Unit  type   ChildQuery   eff   =   Select . Query   Query   String   eff  type   Effects   eff   = \n   (   avar   ::   AVAR \n   ,   dom   ::   DOM \n   ,   ajax   ::   AJAX \n   |   eff \n   )  component   ::   \u2200   eff   m \n   .   MonadAff   ( Effects   eff )   m \n  =   H . Component   HH . HTML   Query   Input   Message   m  component   = \n   H . parentComponent \n     {   initialState \n     ,   render \n     ,   eval \n     ,   receiver :   const   Nothing \n     } \n   where \n\n   initialState   ::   Input   -   State \n   initialState   =   const \n     {   items :   NotAsked \n     ,   selections :   [] \n     } \n\n   fetchItems   ::   String   -   Aff   ( Effects   eff )   ( Either   String   ( Array   String )) \n   fetchItems   str   =   do \n      ( res   ::   Json )   -   _ . response \n        $   get   ( https://swapi.co/api/people/?search=     str ) \n\n      pure   $   do \n        obj   -   decodeJson   res \n        arr   -   obj   .?   results \n        traverse   ( decodeJson   =   flip   ( .? )   name )   arr \n\n   render   ::   State   -   H . ParentHTML   Query   ( ChildQuery   ( Effects   eff ))   ChildSlot   m \n   render   st   = \n     HH . div_ \n     [   HH . slot   unit   Select . component   selectInput   ( HE . input   HandleSelect )   ] \n\n     where \n\n     selectInput   ::   Select . Input   Query   String   ( Effects   eff ) \n     selectInput   = \n       {   inputType :   Select . TextInput \n       ,   items :   [] \n       ,   initialSearch :   Nothing \n       ,   debounceTime :   Just   $   Milliseconds   250.0 \n       ,   render :   typeahead   st \n       } \n\n     typeahead \n       ::   State \n       -   Select . State   String   ( Effects   eff ) \n       -   Select . ComponentHTML   Query   String   ( Effects   eff ) \n     typeahead   parentState   childState   = \n       HH . div_ \n       [   renderSelections ,   renderInput ,   renderContainer   ] \n       where \n         -- The items that have already been selected and can be removed \n         renderSelections   = \n           HH . ul_ \n           (   st . selections   # \n               ( \\ item   - \n                 HH . li \n                 [   HE . onClick   $   Select . always   $   Select . raise   $   Remove   item   unit   ] \n                 [   HH . text   item   ] \n               ) \n           ) \n\n         -- The text input field that will capture key events \n         renderInput   =   HH . input   (   Setters . setInputProps   []   ) \n\n         -- The parent element holding the items  container \n         renderContainer   =   case   childState . visibility   of \n           Select . Off   -   HH . text   \n           Select . On   - \n             HH . ul \n             (   Setters . setContainerProps   []   ) \n             (   case   null   childState . items   of \n                 true   - \n                   mapWithIndex   renderItem   childState . items \n                 _   - \n                   [   HH . li \n                     [   HE . onClick \n                       $   Select . always \n                       $   Select . raise \n                       $   HandleSelect   ( Select . Searched   )   unit \n                     ] \n                     [   HH . text   Fetch data again.   ] \n                   ] \n             ) \n\n         -- Each individual item, which will receive an index and the item \n         renderItem   ix   item   = \n           HH . li \n           (   Setters . setItemProps   ix \n             -- If this is the highlighted item, then apply CSS \n             $   case   Just   ix   ==   childState . highlightedIndex   of \n                 true   -   [   HP . attr   ( HH . AttrName   style )   color: red;   ] \n                 _   -   [] \n           ) \n           [   HH . text   item   ] \n\n\n   eval   ::   Query   ~   H . ParentDSL   State   Query   ( ChildQuery   ( Effects   eff ))   ChildSlot   Message   m \n   eval   =   case   _   of \n     Remove   item   next   -   do \n       H . modify   \\ st   -   st   {   selections   =   filter   ( _   /=   item )   st . selections   } \n       st   -   H . get \n       _   -   H . query   unit \n         $   Select . replaceItems \n         $   difference   ( withDefault   []   st . items )   st . selections \n       pure   next \n\n     HandleSelect   message   next   -   case   message   of \n       Select . Searched   string   -   do \n         H . modify   _   {   items   =   Loading   } \n         _   -   H . query   unit   $   Select . replaceItems   [] \n         newItems   -   H . liftAff   ( fetchItems   string ) \n         H . modify   _   {   items   =   fromEither   newItems   } \n\n         st   -   H . get \n         _   -   H . query   unit \n           $   Select . replaceItems \n           $   difference   ( withDefault   []   st . items )   st . selections \n\n         pure   next \n\n       Select . Selected   item   -   do \n         H . modify   \\ st   -   st   {   selections   =   item   :   st . selections   } \n         st   -   H . get \n         _   -   H . query   unit \n           $   Select . replaceItems \n           $   difference   ( withDefault   []   st . items )   st . selections \n         pure   next \n\n       Select . VisibilityChanged   vis   - \n         pure   next \n\n       Select . Emit   query   -   do \n         eval   query \n         pure   next",
            "title": "Source Code"
        },
        {
            "location": "/how-to/embed-parent-queries/",
            "text": "How to Embed Parent Queries\n\n\nOne of the most powerful ways to extend \nSelect\n is to write functionality in your component, triggered by a query, and then embed that query into the \nSelect\n component.",
            "title": "How to embed parent queries"
        },
        {
            "location": "/how-to/embed-parent-queries/#how-to-embed-parent-queries",
            "text": "One of the most powerful ways to extend  Select  is to write functionality in your component, triggered by a query, and then embed that query into the  Select  component.",
            "title": "How to Embed Parent Queries"
        },
        {
            "location": "/concepts/understanding-free-queries/",
            "text": "Understanding Free Monad Queries\n\n\nMost of the time Halogen queries look like this:\n\n\n1\n2\n3\n4\ndata\n \nQueryF\n \n(\n\u2026\n \nother\n \ntype\n \narguments\n \nomitted\n \n\u2026\n)\n \na\n\n  \n=\n \n...\n\n  \n|\n \nSetVisibility\n \nVisibility\n \na\n\n  \n|\n \nGetVisibility\n \n(\nVisibility\n \n-\n \na\n)\n\n\n\n\n\n\n\n(where \nQueryF\n is used directly as the Halogen query functor)\n\n\nThis library takes a slightly different approach: the query functor is actually \nControl\n.\nMonad\n.\nFree\n.\nFree\n \nQueryF\n, the \nfree monad\n generated by the query functor.\n\n\nThis allows queries the full power of monadic (and applicative) composition: sequencing effects, determining control flow based on previous results, and my favorite: doing nothing (\npure\n \nunit\n).\n\n\nWe now define smart query constructors for this Free pattern like so:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n-- | Set the container visibility (`On` or `Off`).\n\n\nsetVisibility\n \n::\n \n\u2200\n \no\n \nitem\n \neff\n.\n \nVisibility\n \n-\n \nQuery\n \no\n \nitem\n \neff\n \nUnit\n\n\nsetVisibility\n \nv\n \n=\n \nliftF\n \n(\nSetVisibility\n \nv\n \nunit\n)\n\n\n\n-- | Get the container visibility (`On` or `Off`). Most useful when sequenced\n\n\n-- | with other actions.\n\n\ngetVisibility\n \n::\n \n\u2200\n \no\n \nitem\n \neff\n.\n \nQuery\n \no\n \nitem\n \neff\n \nVisibility\n\n\ngetVisibility\n \n=\n \nliftF\n \n(\nGetVisibility\n \nid\n)\n\n\n\n\n\n\n\nDifferent patterns\n\n\nIn the simple cases, the helpers Halogen use to work with raw query constructors are folded into the smart Free query constructors already: \nH\n.\naction\n \n(\nSetVisibility\n \nOn\n)\n becomes simply \nsetVisiblity\n \nOn\n, and similarly \nH\n.\nrequest\n \nGetVisibility\n is just \ngetVisibility\n. This is because these patterns are typically present already smart constructors: \nsetVisibility\n returns \nFree\n \nQueryF\n \nUnit\n, since it is an action, and \ngetVisibility\n returns \nFree\n \nQueryF\n \nVisibility\n, since it requests the visibility. This allows for easy composition in \ndo\n notation:\n\n\n1\n2\n3\ntoggleVisibility\n \n=\n \ndo\n\n  \nvis\n \n-\n \ngetVisibility\n\n  \nsetVisibility\n \n(\nnot\n \nvis\n)\n\n\n\n\n\n\n\nC\u2019est tr\u00e8s facile!\n\n\nEvent handlers look a little different. This is one example:\n\n\n1\n2\n3\n4\nHE\n.\nonMouseDown\n \n\\\nev\n \n-\n \nJust\n \ndo\n\n    \nSelect\n.\npreventClick\n \nev\n\n    \nSelect\n.\nselect\n \nindex\n\n    \nwhen\n \ndoBlur\n \nSelect\n.\ntriggerBlur\n\n\n\n\n\n\n\n(Of course you may return \nNothing\n if you so wish, but its effect is just like \npure\n \nunit\n now.)\n\n\nIf you do not need access to the argument \nev\n, \nSelect\n.\nalways\n provides a simple shortcut for \nconst\n \n \nJust\n:\n\n\n1\nHE\n.\nonMouseOver\n \n$\n \nSelect\n.\nalways\n \n$\n \nSelect\n.\nhighlight\n \n(\nIndex\n \nindex\n)\n\n\n\n\n\n\n\nReturning non-unit values\n\n\nUse \nmap\n or \n$\n or \npure\n to return other types of values from a query. So, instead of something like this:\n\n\n1\n2\nH\n.\nsubscribe\n \n$\n \neventSource\n \nsomeEventSource\n\n  \n\\\nvalue\n \n-\n \nJust\n \n(\nSetVisibility\n \nvalue\n \nH\n.\nListening\n)\n\n\n\n\n\n\n\nUse\n\n\n1\n2\nH\n.\nsubscribe\n \n$\n \neventSource\n \nsomeEventSource\n\n  \n\\\nvalue\n \n-\n \nJust\n \n$\n \nsetVisibility\n \nvalue\n \n$\n \nH\n.\nListening\n\n\n\n\n\n\n\nor\n\n\n1\n2\n3\n4\nH\n.\nsubscribe\n \n$\n \neventSource\n \nsomeEventSource\n\n  \n\\\nvalue\n \n-\n \nJust\n \ndo\n\n    \nsetVisibility\n \nvalue\n\n    \npure\n \nH\n.\nListening\n\n\n\n\n\n\n\n\n\nMany thanks to \nNicholas Scheel\n for providing the implementation of \nQueryF\n and the documentation above.",
            "title": "Understanding free queries"
        },
        {
            "location": "/concepts/understanding-free-queries/#understanding-free-monad-queries",
            "text": "Most of the time Halogen queries look like this:  1\n2\n3\n4 data   QueryF   ( \u2026   other   type   arguments   omitted   \u2026 )   a \n   =   ... \n   |   SetVisibility   Visibility   a \n   |   GetVisibility   ( Visibility   -   a )    (where  QueryF  is used directly as the Halogen query functor)  This library takes a slightly different approach: the query functor is actually  Control . Monad . Free . Free   QueryF , the  free monad  generated by the query functor.  This allows queries the full power of monadic (and applicative) composition: sequencing effects, determining control flow based on previous results, and my favorite: doing nothing ( pure   unit ).  We now define smart query constructors for this Free pattern like so:  1\n2\n3\n4\n5\n6\n7\n8 -- | Set the container visibility (`On` or `Off`).  setVisibility   ::   \u2200   o   item   eff .   Visibility   -   Query   o   item   eff   Unit  setVisibility   v   =   liftF   ( SetVisibility   v   unit )  -- | Get the container visibility (`On` or `Off`). Most useful when sequenced  -- | with other actions.  getVisibility   ::   \u2200   o   item   eff .   Query   o   item   eff   Visibility  getVisibility   =   liftF   ( GetVisibility   id )",
            "title": "Understanding Free Monad Queries"
        },
        {
            "location": "/concepts/understanding-free-queries/#different-patterns",
            "text": "In the simple cases, the helpers Halogen use to work with raw query constructors are folded into the smart Free query constructors already:  H . action   ( SetVisibility   On )  becomes simply  setVisiblity   On , and similarly  H . request   GetVisibility  is just  getVisibility . This is because these patterns are typically present already smart constructors:  setVisibility  returns  Free   QueryF   Unit , since it is an action, and  getVisibility  returns  Free   QueryF   Visibility , since it requests the visibility. This allows for easy composition in  do  notation:  1\n2\n3 toggleVisibility   =   do \n   vis   -   getVisibility \n   setVisibility   ( not   vis )    C\u2019est tr\u00e8s facile!  Event handlers look a little different. This is one example:  1\n2\n3\n4 HE . onMouseDown   \\ ev   -   Just   do \n     Select . preventClick   ev \n     Select . select   index \n     when   doBlur   Select . triggerBlur    (Of course you may return  Nothing  if you so wish, but its effect is just like  pure   unit  now.)  If you do not need access to the argument  ev ,  Select . always  provides a simple shortcut for  const     Just :  1 HE . onMouseOver   $   Select . always   $   Select . highlight   ( Index   index )",
            "title": "Different patterns"
        },
        {
            "location": "/concepts/understanding-free-queries/#returning-non-unit-values",
            "text": "Use  map  or  $  or  pure  to return other types of values from a query. So, instead of something like this:  1\n2 H . subscribe   $   eventSource   someEventSource \n   \\ value   -   Just   ( SetVisibility   value   H . Listening )    Use  1\n2 H . subscribe   $   eventSource   someEventSource \n   \\ value   -   Just   $   setVisibility   value   $   H . Listening    or  1\n2\n3\n4 H . subscribe   $   eventSource   someEventSource \n   \\ value   -   Just   do \n     setVisibility   value \n     pure   H . Listening     Many thanks to  Nicholas Scheel  for providing the implementation of  QueryF  and the documentation above.",
            "title": "Returning non-unit values"
        },
        {
            "location": "/examples/",
            "text": "Examples\n\n\nYou can play around with a few example components here. However, for a much richer set of components with much more functionality, check out the \nOcelot design system by CitizenNet\n.\n\n\n\n\nWarning\n\n\nThe components on this page function properly, but look horrible while we migrate CSS.\n\n\n\n\nDropdown\n\n\nDropdowns are a common button-driven input type, especially for navigation. But most custom dropdowns sacrifice usability: unlike browser default dropdowns, you can't type on most custom dropdowns, nor are many built with accessibility in mind. With \nSelect\n you can easily create rich, usable dropdowns with little code.\n\n\n\n\n\nCurious how to build a dropdown with \nSelect\n? Check out \nthe dropdown tutorial\n.\n\n\nTypeahead / Autocomplete\n\n\nThis library was originally designed so that we could build typeaheads with all sorts of custom rendering and functionality. It was frustrating to find solutions that almost worked, but broke down as soon as you needed a moderate level of customization.\n\n\nBuilding typeaheads with \nSelect\n is only a little more complex than building dropdowns. Instead of a button as input, you'll use a text input, and you'll be responsible for deciding how to handle user searches. \nSelect\n handles debouncing user input, keyboard navigation, and more on your behalf.\n\n\nThe typeahead below is quite simple; to see examples of more sophisticated typeaheads -- including ones that fetch and display data asynchronously -- check out the \nOcelot component library\n.\n\n\n\n\n\nCurious how to build a typeahead with \nSelect\n? Check out \nthe typeahead tutorial\n.",
            "title": "Examples"
        },
        {
            "location": "/examples/#examples",
            "text": "You can play around with a few example components here. However, for a much richer set of components with much more functionality, check out the  Ocelot design system by CitizenNet .   Warning  The components on this page function properly, but look horrible while we migrate CSS.",
            "title": "Examples"
        },
        {
            "location": "/examples/#dropdown",
            "text": "Dropdowns are a common button-driven input type, especially for navigation. But most custom dropdowns sacrifice usability: unlike browser default dropdowns, you can't type on most custom dropdowns, nor are many built with accessibility in mind. With  Select  you can easily create rich, usable dropdowns with little code.   Curious how to build a dropdown with  Select ? Check out  the dropdown tutorial .",
            "title": "Dropdown"
        },
        {
            "location": "/examples/#typeahead-autocomplete",
            "text": "This library was originally designed so that we could build typeaheads with all sorts of custom rendering and functionality. It was frustrating to find solutions that almost worked, but broke down as soon as you needed a moderate level of customization.  Building typeaheads with  Select  is only a little more complex than building dropdowns. Instead of a button as input, you'll use a text input, and you'll be responsible for deciding how to handle user searches.  Select  handles debouncing user input, keyboard navigation, and more on your behalf.  The typeahead below is quite simple; to see examples of more sophisticated typeaheads -- including ones that fetch and display data asynchronously -- check out the  Ocelot component library .   Curious how to build a typeahead with  Select ? Check out  the typeahead tutorial .",
            "title": "Typeahead / Autocomplete"
        }
    ]
}