{
    "docs": [
        {
            "location": "/",
            "text": "Welcome\n\n\nSelect\n helps you build selection user interfaces in PureScript with Halogen. You can use it to build dropdowns, typeaheads and autocompletes, date pickers, image pickers, and more, with features like keyboard navigation, accessibility, and state management handled for you. This library takes a unique approach to component design to ensure you can leverage its features without compromising your design in any way.\n\n\nInstallation\n\n\nYou can use \nSelect\n in your PureScript project with a compatible package manager. The PureScript community typically leverages \npsc-package\n or Bower:\n\n\n1\n2\n3\n4\n5\n# Using psc-package\n\n$ psc-package install halogen-select\n\n\n# Using Bower\n\n$ bower install --save purescript-halogen-select\n\n\n\n\n\n\nQuick Start\n\n\nIf this is your first time using \nSelect\n, start with the \ntutorials\n. I'd recommend starting with the simplest example where you'll learn to make this dropdown component:\n\n\n\n\n\n\n\nTip\n\n\nDon't want to build your own UI components? Check out the \nOcelot component library\n!\n\n\n\n\nIf this isn't your first time, you'll find value in these resources:\n\n\n\n\nThe \nhow-to\n section contains plenty of short guides for common tasks you'll perform using \nSelect\n. Consider it a grab-bag of useful strategies and examples you can refer to when developing new components.\n\n\nThe \nconcepts\n section contains more detailed explanations on the design of the library. It will help you understand how to make good design choices and make the most of the tools available to you.\n\n\nThe \nreference documentation on Pursuit\n contains the module documentation and source code. It's a useful reference to verify what functions are available to you.\n\n\nThe \nexamples folder on Github\n contains the working source code for all the components in the \ntutorials\n. If you're building a similar component, this code can help you get started.\n\n\n\n\nWhy Select?\n\n\nSelect\n provides essential behaviors for selection UI as a flexible, extensible Halogen component. But you won't find a single render function in the code. Instead, with a few helper functions, you can write your own \nState\n \n-\n \nHTML\n function however you'd like. You can:\n\n\n\n\nExtend the component's functionality by embedding new queries in the HTML\n\n\nExtend the component's data by including as much additional state from the parent as you want (which you can then use in your render function)\n\n\nLeverage the provided features for user interaction, state management, accessibility, and logic\n\n\nRetain complete freedom over the design and aesthetic of your selection component\n\n\n\n\n\n\nFor visual learners\n\n\nI gave a talk at the Los Angeles PureScript meetup in April 2018 about the approach this library takes. It provides an overview of our design approach, including advantages and drawbacks, as well as a simple walkthrough of building a dropdown. No, the man in the preview isn't me -- that's \nPhil Freeman\n, the designer of the PureScript programming language.",
            "title": "Home"
        },
        {
            "location": "/#welcome",
            "text": "Select  helps you build selection user interfaces in PureScript with Halogen. You can use it to build dropdowns, typeaheads and autocompletes, date pickers, image pickers, and more, with features like keyboard navigation, accessibility, and state management handled for you. This library takes a unique approach to component design to ensure you can leverage its features without compromising your design in any way.",
            "title": "Welcome"
        },
        {
            "location": "/#installation",
            "text": "You can use  Select  in your PureScript project with a compatible package manager. The PureScript community typically leverages  psc-package  or Bower:  1\n2\n3\n4\n5 # Using psc-package \n$ psc-package install halogen-select # Using Bower \n$ bower install --save purescript-halogen-select",
            "title": "Installation"
        },
        {
            "location": "/#quick-start",
            "text": "If this is your first time using  Select , start with the  tutorials . I'd recommend starting with the simplest example where you'll learn to make this dropdown component:    Tip  Don't want to build your own UI components? Check out the  Ocelot component library !   If this isn't your first time, you'll find value in these resources:   The  how-to  section contains plenty of short guides for common tasks you'll perform using  Select . Consider it a grab-bag of useful strategies and examples you can refer to when developing new components.  The  concepts  section contains more detailed explanations on the design of the library. It will help you understand how to make good design choices and make the most of the tools available to you.  The  reference documentation on Pursuit  contains the module documentation and source code. It's a useful reference to verify what functions are available to you.  The  examples folder on Github  contains the working source code for all the components in the  tutorials . If you're building a similar component, this code can help you get started.",
            "title": "Quick Start"
        },
        {
            "location": "/#why-select",
            "text": "Select  provides essential behaviors for selection UI as a flexible, extensible Halogen component. But you won't find a single render function in the code. Instead, with a few helper functions, you can write your own  State   -   HTML  function however you'd like. You can:   Extend the component's functionality by embedding new queries in the HTML  Extend the component's data by including as much additional state from the parent as you want (which you can then use in your render function)  Leverage the provided features for user interaction, state management, accessibility, and logic  Retain complete freedom over the design and aesthetic of your selection component    For visual learners  I gave a talk at the Los Angeles PureScript meetup in April 2018 about the approach this library takes. It provides an overview of our design approach, including advantages and drawbacks, as well as a simple walkthrough of building a dropdown. No, the man in the preview isn't me -- that's  Phil Freeman , the designer of the PureScript programming language.",
            "title": "Why Select?"
        },
        {
            "location": "/tutorials/getting-started/",
            "text": "Introduction\n\n\nHalogen is a powerful framework for building PureScript applications. It\u2019s used by several companies, including SlamData and my own company, CitizenNet (a Cond\u00e9 Nast company), among others. The \nSelect\n library is written for the Halogen framework, so if you don\u2019t know how to use Halogen yet, you ought to start with the \nHalogen guide\n. That said, with only passing familiarity with Halogen, you should be able to follow along just fine!\n\n\nSetup\n\n\nInstead of creating a new Halogen project from scratch, we\u2019ll start with a minimal starter template. This template includes the HTML, build scripts, and basic \nMain.purs\n file necessary to run your Halogen application. It also includes a component with the bare minimum definitions in place. This component does nothing at all, which is nice because we can easily use it to start building dropdowns, typeaheads, and other components.\n\n\n\n\nWe prefer Yarn over NPM for package management and scripts, but either one will work. Anywhere you see \nyarn \nscript\n, you can substitute \nnpm run \nscript\n instead. Feel free to look at the \npackage.json\n file if you want to see what these scripts are doing.\n\n\n\n\nInstallation\n\n\nFirst, clone the Halogen template project from CitizenNet, install dependencies, and make sure things build properly. If they don\u2019t, please reach out on the \nPurescript user forum\n so we can fix it!\n\n\nNext, make sure to install \nSelect\n:\n\n\n1\nbower i --save purescript-halogen-select\n\n\n\n\n\n\nAnd that's it! You now have everything you need to complete the tutorials. This is the full set of steps you can follow to get all set up:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n# Get the CitizenNet starter Halogen project\n\ngit clone git@github.com:citizennet/purescript-halogen-template.git\n\n\n# Change into the directory and install packages\n\n\ncd\n purescript-halogen-template \n yarn\n\n\n# Install a new package: purescript-halogen-select\n\nbower i --save purescript-halogen-select\n\n\n# Build the project\n\nyarn build\n\n\n# Open the application in the browser\n\nopen dist/index.html\n\n\n\n\n\n\nAfter you complete a step in the tutorial, make sure to rebuild the project and refresh your browser to see your updated component.\n\n\nHelpful tip: Watching for file changes\n\n\nIt\u2019s convenient to keep a terminal running which watches for file changes, rebuilds the project, and bundles JavaScript on your behalf. Then, when you make a change to a file, all you have to do is wait a moment and refresh the page to see your updates.\n\n\nWhen I write PureScript, I usually work with two terminals open. I use the first to write code, and the second to watch those changes and rebuild. I recommend using the same technique as you walk through these tutorials. These three steps are all you need:\n\n\n\n\nOpen a new terminal and run the \nwatch\n script\n\n\nOpen your editor to a source file\n\n\nOpen a new tab in your browser pointed to \ndist/index.html\n so you can see the app\n\n\n\n\nTo test everything is working, try editing \nsrc/Component.purs\n to change the title of the page. The project should automatically rebuild on save. Then, when you refresh the browser, you should see your new text rendered.\n\n\n1\n2\n# Watch for changes and rebuild (remember to refresh the page after builds)\n\nyarn watch\n\n\n\n\n\n\nA whirlwind tour of our starter component\n\n\nThe project starts off with a minimal Halogen component. As a brief refresher, I'll step through each of the types and functions involved.\n\n\n\n\nInfo\n\n\nIf you are already quite familiar with Halogen, feel free to skip this section entirely.\n\n\n\n\nQuery Algebra\n\n\nHow does a component know what to do?\n\n\nIn Halogen, we give names to each computation we'd like a component to run. Computations that can side effects but don't return anything are colloquially called \nactions\n; those that can have side effects and also return something are called \nrequests\n. The type that lists out the possible actions and requests for a component is called the component's \nquery algebra\n. The Halogen guide has a relevant \nsection about query algebras\n if you'd like to know more.\n\n\nWhat actions and requests can our starter component perform? By looking at the query algebra, we see just one constructor:\n\n\n1\n2\ndata\n \nQuery\n \na\n\n  \n=\n \nNoOp\n \na\n\n\n\n\n\n\n\nAll we know so far is that this component can do one thing: evaluate a query called \nNoOp\n. We'll see what it does later on when we look at the \neval\n function.\n\n\nState\n\n\nEvery component encapsulates some state, described by its \nState\n type. You will usually see Halogen components use records to hold state, like this:\n\n\n1\ntype\n \nState\n \n=\n \n{\n \non\n \n::\n \nBoolean\n,\n \nname\n \n::\n \nString\n \n}\n\n\n\n\n\n\n\nState is the core of your component. Most of the queries you see in Halogen components modify state in some way, and the render function that produces HTML for the component has only the \nState\n type as its argument.\n\n\nFor our starter component, we don't need any state just yet, so we've simply assigned it the \nUnit\n type. When we start building selection components, however, we'll soon create a record to hold our state.\n\n\n1\ntype\n \nState\n \n=\n \nUnit\n\n\n\n\n\n\n\nInput\n\n\nA component's \nInput\n type can be thought of as a container for any information you'd like to pass to the component. It's most commonly used to provide a component with some initial \nState\n values via the \ninitialState\n \n::\n \nInput\n \n-\n \nState\n function. However, it's more powerful than that!\n\n\nOnce a Halogen component has been mounted to the DOM, there is only one way to continue sending it new information: its \nInput\n type paired with its \nreceiver\n function. Every time the parent component re-renders, it will send a new \nInput\n to the child component.\n\n\nFor more information on the \nInput\n type, see the \nParent and Child Components\n section of the Halogen guide.\n\n\nOur starter component doesn't need any input, so we'll assign it the \nUnit\n type. However, once we build a dropdown or typeahead, we'll probably want to receive the list of items that can be selected as input.\n\n\n1\ntype\n \nInput\n \n=\n \nUnit\n\n\n\n\n\n\n\nMessage\n\n\nHow does a component tell its parent when something important has happened? In Halogen, this is accomplished with a \nMessage\n type. Like the query algebra, this is just a type describing messages that can be raised, containing some information. To actually trigger sending a particular message, you can use the \nraise\n function provided by Halogen.\n\n\nWhen we start building selection components, we'll use messages to notify parent components when items have been selected or removed. Our starter component doesn't need to raise any messages, however, so we've given it the \nVoid\n type.\n\n\nWhy are we using \nVoid\n when we have no messages?\nWhy use \nVoid\n instead of \nUnit\n for the \nMessage\n type when it has no constructors? This is common practice in Halogen because of how messages are used by parent components. When your component raises a message, it gets handled by the parent using a function like this:\nChild\n.\nMessage\n \n-\n \nMaybe\n \n(\nParentQuery\n \nUnit\n)\nIf you want to ignore all messages from the child, you could write an implementation like this:\nHalogen\n.\nHTML\n.\nEvents\n.\ninput\n \n \nconst\n \nNothing\nHowever, if the child's message type is \nVoid\n, then you can use the \nabsurd\n function from \nData.Void\n:\nabsurd\n \n::\n \nVoid\n \n-\n \na\nThis saves you a bit of typing when you mount a child component in a slot and makes it absolutely unambiguous that there are no messages to handle. It also ensures that if you add a message to the child component later on you'll get a compiler error -- this is a good thing!\nCompare mounting a child component that uses \nUnit\n to represent \"no messages\" vs. using \nVoid\n:\n1\n2\n3\n4\n5\n6\n7\n-- It\ns unclear whether you\nre ignoring all messages or whether there are\n\n\n-- simply no messages to handle.\n\n\nHH\n.\nslot\n \nComponentSlot\n \ncomponent\n \nunit\n \n(\nHalogen\n.\nHTML\n.\nEvents\n.\ninput\n \n \nconst\n \nNothing\n)\n\n\n\n-- It\ns obvious there are no messages, and if that changes (the component adds a\n\n\n-- message) you\nll get a nice compile-time error.\n\n\nHH\n.\nslot\n \nComponentSlot\n \ncomponent\n \nunit\n \nabsurd\n\n\n\n\n\n\nFor more information on messages, see the \nParent and Child Components\n section in the Halogen guide.\n\n\n1\ntype\n \nMessage\n \n=\n \nVoid\n\n\n\n\n\n\n\nChildQuery and ChildSlot\n\n\nHalogen components often have further child components. To maintain type safety when managing multiple child components, Halogen uses a pair of concepts: \nchild queries\n and \nchild slots\n.\n\n\n\n\n\n\nThe \nChildQuery\n type lists out each unique type of child component your component has. For each type of child component, you'll add its query type here.\n\n\n\n\n\n\nThe \nChildSlot\n type works like an address book for the various child components. If you only have one child component of any distinct \nChildQuery\n, then you can just use \nunit\n. However, if you have multiple children with the same query type, you need some way to distinguish between them. It's common to use custom types or integers for this.\n\n\n\n\n\n\nSee the \nMultiple Types of Child Component\n section of the Halogen guide for more details.\n\n\nFor now, our component has no children. Once we bring in the \nSelect\n component we'll update these types.\n\n\n1\n2\ntype\n \nChildQuery\n \n=\n \nConst\n \nVoid\n\n\ntype\n \nChildSlot\n \n=\n \nUnit\n\n\n\n\n\n\n\nComponent\n\n\nAh! We can finally create our component. The actual component definition is simple: we call the \nparentComponent\n function from Halogen to assert we're creating a component that can have further child components and provide it with the four functions it needs to operate. More on those in a moment!\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\ncomponent\n \n::\n \n\u2200\n \neff\n \nm\n\n  \n.\n \nMonadAff\n \neff\n \nm\n\n \n=\n \nH\n.\nComponent\n \nHH\n.\nHTML\n \nQuery\n \nInput\n \nMessage\n \nm\n\n\ncomponent\n \n=\n\n  \nH\n.\nparentComponent\n\n    \n{\n \ninitialState\n\n    \n,\n \nrender\n\n    \n,\n \neval\n\n    \n,\n \nreceiver\n:\n \nconst\n \nNothing\n\n    \n}\n\n\n  \nwhere\n\n\n\n\n\n\n\nNext, lets look at those function definitions, defined in the \nwhere\n clause:\n\n\ninitialState\n\n\nThe \ninitialState\n function describes how to go from the component's \nInput\n type to its \nState\n type. In this case, our \nState\n type is just \nUnit\n, so we'll throw away the input and return \nunit\n.\n\n\n1\n2\n3\n4\n5\ninitialState\n \n::\n \nInput\n \n-\n \nState\n\n\ninitialState\n \n=\n \nconst\n \nunit\n\n\n\n-- Could also be written this way:\n\n\ninitialState\n \n=\n \nid\n\n\n\n\n\n\n\nrender\n\n\nThe \nrender\n function describes how to go from the component's \nState\n type to some HTML, where that HTML can include any of the components listed in the \nChildQuery\n type. You'll use plenty of code from these modules when writing render functions:\n\n\n1\n2\n3\nimport\n \nHalogen.HTML\n \nas\n \nHH\n\n\nimport\n \nHalogen.HTML.Events\n \nas\n \nHE\n\n\nimport\n \nHalogen.HTML.Properties\n \nas\n \nHP\n\n\n\n\n\n\n\nWe're going to spend a lot of time writing render functions in the following tutorials. You can refer to the Halogen guide's \nsection on rendering\n for more information.\n\n\nFor now we won't render anything to the page, represented by an empty div.\n\n\n1\n2\nrender\n \n::\n \nState\n \n-\n \nH\n.\nParentHTML\n \nQuery\n \nChildQuery\n \nChildSlot\n \nm\n\n\nrender\n \nst\n \n=\n \nHH\n.\ndiv_\n \n[]\n\n\n\n\n\n\n\neval\n\n\nThe \neval\n function describes what to do when one of the queries from the component's query algebra is called. There are various ways a query can be triggered:\n\n\n\n\nThe parent component can trigger a child component query using the \nquery\n function\n\n\nA user can trigger a query with an event in HTML, like \nonClick\n\n\nThe \neval\n function can recursively call itself while evaluating a query\n\n\n\n\nThe \neval\n function is where you get to actually define what all your queries \ndo\n. Unlike the render function, you can actually perform all kinds of side effects here, like make API calls, update state, trigger queries in child components, raise messages, and more.\n\n\nAs usual, our starter component won't do much in its \neval\n. When it receives the \nNoOp\n constructor, it will do nothing and return the next query.\n\n\n1\n2\n3\neval\n \n::\n \nQuery\n \n~\n \nH\n.\nParentDSL\n \nState\n \nQuery\n \nChildQuery\n \nChildSlot\n \nMessage\n \nm\n\n\neval\n \n=\n \ncase\n \n_\n \nof\n\n  \nNoOp\n \nnext\n \n-\n \npure\n \nnext\n\n\n\n\n\n\n\nreceiver\n\n\nThe \nreceiver\n function describes what to do when a parent component sends in new \nInput\n. Its type signature looks like this:\n\n\n1\nreceiver\n \n::\n \nInput\n \n-\n \nMaybe\n \n(\nQuery\n \nUnit\n)\n\n\n\n\n\n\n\nOnce a Halogen component has been mounted, the only way to send it new input is via its \nreceiver\n function. When its parent re-renders, it will automatically send the child component's input type again, and it's up to the \nreceiver\n function to decide what to do with it.\n\n\nThis function can either provide a query to call, or \nNothing\n if you'd like to ignore new input. If you elect to provide a query then you unlock all the power available in the \neval\n function and can describe all sorts of things to do on new input, like making API calls or updating state.\n\n\nIn our case, we don't care about new input, so we'll ignore the input and return \nNothing\n.\n\n\n1\n2\n3\n{\n \n...\n\n\n,\n \nreceiver\n:\n \nconst\n \nNothing\n\n\n}",
            "title": "Project setup"
        },
        {
            "location": "/tutorials/getting-started/#introduction",
            "text": "Halogen is a powerful framework for building PureScript applications. It\u2019s used by several companies, including SlamData and my own company, CitizenNet (a Cond\u00e9 Nast company), among others. The  Select  library is written for the Halogen framework, so if you don\u2019t know how to use Halogen yet, you ought to start with the  Halogen guide . That said, with only passing familiarity with Halogen, you should be able to follow along just fine!",
            "title": "Introduction"
        },
        {
            "location": "/tutorials/getting-started/#setup",
            "text": "Instead of creating a new Halogen project from scratch, we\u2019ll start with a minimal starter template. This template includes the HTML, build scripts, and basic  Main.purs  file necessary to run your Halogen application. It also includes a component with the bare minimum definitions in place. This component does nothing at all, which is nice because we can easily use it to start building dropdowns, typeaheads, and other components.   We prefer Yarn over NPM for package management and scripts, but either one will work. Anywhere you see  yarn  script , you can substitute  npm run  script  instead. Feel free to look at the  package.json  file if you want to see what these scripts are doing.",
            "title": "Setup"
        },
        {
            "location": "/tutorials/getting-started/#installation",
            "text": "First, clone the Halogen template project from CitizenNet, install dependencies, and make sure things build properly. If they don\u2019t, please reach out on the  Purescript user forum  so we can fix it!  Next, make sure to install  Select :  1 bower i --save purescript-halogen-select   And that's it! You now have everything you need to complete the tutorials. This is the full set of steps you can follow to get all set up:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 # Get the CitizenNet starter Halogen project \ngit clone git@github.com:citizennet/purescript-halogen-template.git # Change into the directory and install packages  cd  purescript-halogen-template   yarn # Install a new package: purescript-halogen-select \nbower i --save purescript-halogen-select # Build the project \nyarn build # Open the application in the browser \nopen dist/index.html   After you complete a step in the tutorial, make sure to rebuild the project and refresh your browser to see your updated component.",
            "title": "Installation"
        },
        {
            "location": "/tutorials/getting-started/#helpful-tip-watching-for-file-changes",
            "text": "It\u2019s convenient to keep a terminal running which watches for file changes, rebuilds the project, and bundles JavaScript on your behalf. Then, when you make a change to a file, all you have to do is wait a moment and refresh the page to see your updates.  When I write PureScript, I usually work with two terminals open. I use the first to write code, and the second to watch those changes and rebuild. I recommend using the same technique as you walk through these tutorials. These three steps are all you need:   Open a new terminal and run the  watch  script  Open your editor to a source file  Open a new tab in your browser pointed to  dist/index.html  so you can see the app   To test everything is working, try editing  src/Component.purs  to change the title of the page. The project should automatically rebuild on save. Then, when you refresh the browser, you should see your new text rendered.  1\n2 # Watch for changes and rebuild (remember to refresh the page after builds) \nyarn watch",
            "title": "Helpful tip: Watching for file changes"
        },
        {
            "location": "/tutorials/getting-started/#a-whirlwind-tour-of-our-starter-component",
            "text": "The project starts off with a minimal Halogen component. As a brief refresher, I'll step through each of the types and functions involved.   Info  If you are already quite familiar with Halogen, feel free to skip this section entirely.",
            "title": "A whirlwind tour of our starter component"
        },
        {
            "location": "/tutorials/getting-started/#query-algebra",
            "text": "How does a component know what to do?  In Halogen, we give names to each computation we'd like a component to run. Computations that can side effects but don't return anything are colloquially called  actions ; those that can have side effects and also return something are called  requests . The type that lists out the possible actions and requests for a component is called the component's  query algebra . The Halogen guide has a relevant  section about query algebras  if you'd like to know more.  What actions and requests can our starter component perform? By looking at the query algebra, we see just one constructor:  1\n2 data   Query   a \n   =   NoOp   a    All we know so far is that this component can do one thing: evaluate a query called  NoOp . We'll see what it does later on when we look at the  eval  function.",
            "title": "Query Algebra"
        },
        {
            "location": "/tutorials/getting-started/#state",
            "text": "Every component encapsulates some state, described by its  State  type. You will usually see Halogen components use records to hold state, like this:  1 type   State   =   {   on   ::   Boolean ,   name   ::   String   }    State is the core of your component. Most of the queries you see in Halogen components modify state in some way, and the render function that produces HTML for the component has only the  State  type as its argument.  For our starter component, we don't need any state just yet, so we've simply assigned it the  Unit  type. When we start building selection components, however, we'll soon create a record to hold our state.  1 type   State   =   Unit",
            "title": "State"
        },
        {
            "location": "/tutorials/getting-started/#input",
            "text": "A component's  Input  type can be thought of as a container for any information you'd like to pass to the component. It's most commonly used to provide a component with some initial  State  values via the  initialState   ::   Input   -   State  function. However, it's more powerful than that!  Once a Halogen component has been mounted to the DOM, there is only one way to continue sending it new information: its  Input  type paired with its  receiver  function. Every time the parent component re-renders, it will send a new  Input  to the child component.  For more information on the  Input  type, see the  Parent and Child Components  section of the Halogen guide.  Our starter component doesn't need any input, so we'll assign it the  Unit  type. However, once we build a dropdown or typeahead, we'll probably want to receive the list of items that can be selected as input.  1 type   Input   =   Unit",
            "title": "Input"
        },
        {
            "location": "/tutorials/getting-started/#message",
            "text": "How does a component tell its parent when something important has happened? In Halogen, this is accomplished with a  Message  type. Like the query algebra, this is just a type describing messages that can be raised, containing some information. To actually trigger sending a particular message, you can use the  raise  function provided by Halogen.  When we start building selection components, we'll use messages to notify parent components when items have been selected or removed. Our starter component doesn't need to raise any messages, however, so we've given it the  Void  type.  Why are we using  Void  when we have no messages? Why use  Void  instead of  Unit  for the  Message  type when it has no constructors? This is common practice in Halogen because of how messages are used by parent components. When your component raises a message, it gets handled by the parent using a function like this: Child . Message   -   Maybe   ( ParentQuery   Unit ) If you want to ignore all messages from the child, you could write an implementation like this: Halogen . HTML . Events . input     const   Nothing However, if the child's message type is  Void , then you can use the  absurd  function from  Data.Void : absurd   ::   Void   -   a This saves you a bit of typing when you mount a child component in a slot and makes it absolutely unambiguous that there are no messages to handle. It also ensures that if you add a message to the child component later on you'll get a compiler error -- this is a good thing! Compare mounting a child component that uses  Unit  to represent \"no messages\" vs. using  Void : 1\n2\n3\n4\n5\n6\n7 -- It s unclear whether you re ignoring all messages or whether there are  -- simply no messages to handle.  HH . slot   ComponentSlot   component   unit   ( Halogen . HTML . Events . input     const   Nothing )  -- It s obvious there are no messages, and if that changes (the component adds a  -- message) you ll get a nice compile-time error.  HH . slot   ComponentSlot   component   unit   absurd    For more information on messages, see the  Parent and Child Components  section in the Halogen guide.  1 type   Message   =   Void",
            "title": "Message"
        },
        {
            "location": "/tutorials/getting-started/#childquery-and-childslot",
            "text": "Halogen components often have further child components. To maintain type safety when managing multiple child components, Halogen uses a pair of concepts:  child queries  and  child slots .    The  ChildQuery  type lists out each unique type of child component your component has. For each type of child component, you'll add its query type here.    The  ChildSlot  type works like an address book for the various child components. If you only have one child component of any distinct  ChildQuery , then you can just use  unit . However, if you have multiple children with the same query type, you need some way to distinguish between them. It's common to use custom types or integers for this.    See the  Multiple Types of Child Component  section of the Halogen guide for more details.  For now, our component has no children. Once we bring in the  Select  component we'll update these types.  1\n2 type   ChildQuery   =   Const   Void  type   ChildSlot   =   Unit",
            "title": "ChildQuery and ChildSlot"
        },
        {
            "location": "/tutorials/getting-started/#component",
            "text": "Ah! We can finally create our component. The actual component definition is simple: we call the  parentComponent  function from Halogen to assert we're creating a component that can have further child components and provide it with the four functions it needs to operate. More on those in a moment!   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 component   ::   \u2200   eff   m \n   .   MonadAff   eff   m \n  =   H . Component   HH . HTML   Query   Input   Message   m  component   = \n   H . parentComponent \n     {   initialState \n     ,   render \n     ,   eval \n     ,   receiver :   const   Nothing \n     } \n\n   where    Next, lets look at those function definitions, defined in the  where  clause:",
            "title": "Component"
        },
        {
            "location": "/tutorials/getting-started/#initialstate",
            "text": "The  initialState  function describes how to go from the component's  Input  type to its  State  type. In this case, our  State  type is just  Unit , so we'll throw away the input and return  unit .  1\n2\n3\n4\n5 initialState   ::   Input   -   State  initialState   =   const   unit  -- Could also be written this way:  initialState   =   id",
            "title": "initialState"
        },
        {
            "location": "/tutorials/getting-started/#render",
            "text": "The  render  function describes how to go from the component's  State  type to some HTML, where that HTML can include any of the components listed in the  ChildQuery  type. You'll use plenty of code from these modules when writing render functions:  1\n2\n3 import   Halogen.HTML   as   HH  import   Halogen.HTML.Events   as   HE  import   Halogen.HTML.Properties   as   HP    We're going to spend a lot of time writing render functions in the following tutorials. You can refer to the Halogen guide's  section on rendering  for more information.  For now we won't render anything to the page, represented by an empty div.  1\n2 render   ::   State   -   H . ParentHTML   Query   ChildQuery   ChildSlot   m  render   st   =   HH . div_   []",
            "title": "render"
        },
        {
            "location": "/tutorials/getting-started/#eval",
            "text": "The  eval  function describes what to do when one of the queries from the component's query algebra is called. There are various ways a query can be triggered:   The parent component can trigger a child component query using the  query  function  A user can trigger a query with an event in HTML, like  onClick  The  eval  function can recursively call itself while evaluating a query   The  eval  function is where you get to actually define what all your queries  do . Unlike the render function, you can actually perform all kinds of side effects here, like make API calls, update state, trigger queries in child components, raise messages, and more.  As usual, our starter component won't do much in its  eval . When it receives the  NoOp  constructor, it will do nothing and return the next query.  1\n2\n3 eval   ::   Query   ~   H . ParentDSL   State   Query   ChildQuery   ChildSlot   Message   m  eval   =   case   _   of \n   NoOp   next   -   pure   next",
            "title": "eval"
        },
        {
            "location": "/tutorials/getting-started/#receiver",
            "text": "The  receiver  function describes what to do when a parent component sends in new  Input . Its type signature looks like this:  1 receiver   ::   Input   -   Maybe   ( Query   Unit )    Once a Halogen component has been mounted, the only way to send it new input is via its  receiver  function. When its parent re-renders, it will automatically send the child component's input type again, and it's up to the  receiver  function to decide what to do with it.  This function can either provide a query to call, or  Nothing  if you'd like to ignore new input. If you elect to provide a query then you unlock all the power available in the  eval  function and can describe all sorts of things to do on new input, like making API calls or updating state.  In our case, we don't care about new input, so we'll ignore the input and return  Nothing .  1\n2\n3 {   ...  ,   receiver :   const   Nothing  }",
            "title": "receiver"
        },
        {
            "location": "/tutorials/dropdown/",
            "text": "Let's Build a Dropdown\n\n\nDropdowns are among the simplest selection components you will build, but they can be tricky to get right. For example, you'll likely want to ensure that your users can type to highlight close text matches (like when you type \"Ca\" to highlight \"California\" in a state dropdown). You'll want to be accessible to folks using screen readers or keyboard-only navigation, too. And, of course, you'll want to achieve all this without compromising on your design.\n\n\nIn this tutorial, we'll build a dropdown together using \nSelect\n. It will be ugly but functional; we won't worry much about CSS.\n\n\n\n\nThis tutorial assumes you've followed the steps in the \nProject Setup\n section. While not necessary, this code is tested with those steps in mind.\n\n\nYour code should work at the end of every step. If you run into issues or your code doesn't compile, please come visit us on the \nPureScript user forum\n or the \n#fpchat Slack channel\n.",
            "title": "Build a dropdown"
        },
        {
            "location": "/tutorials/dropdown/#lets-build-a-dropdown",
            "text": "Dropdowns are among the simplest selection components you will build, but they can be tricky to get right. For example, you'll likely want to ensure that your users can type to highlight close text matches (like when you type \"Ca\" to highlight \"California\" in a state dropdown). You'll want to be accessible to folks using screen readers or keyboard-only navigation, too. And, of course, you'll want to achieve all this without compromising on your design.  In this tutorial, we'll build a dropdown together using  Select . It will be ugly but functional; we won't worry much about CSS.   This tutorial assumes you've followed the steps in the  Project Setup  section. While not necessary, this code is tested with those steps in mind.  Your code should work at the end of every step. If you run into issues or your code doesn't compile, please come visit us on the  PureScript user forum  or the  #fpchat Slack channel .",
            "title": "Let's Build a Dropdown"
        },
        {
            "location": "/how-to/embed-parent-queries/",
            "text": "How to Embed Parent Queries\n\n\nOne of the most powerful ways to extend \nSelect\n is to write functionality in your component, triggered by a query, and then embed that query into the \nSelect\n component.",
            "title": "How to embed parent queries"
        },
        {
            "location": "/how-to/embed-parent-queries/#how-to-embed-parent-queries",
            "text": "One of the most powerful ways to extend  Select  is to write functionality in your component, triggered by a query, and then embed that query into the  Select  component.",
            "title": "How to Embed Parent Queries"
        },
        {
            "location": "/concepts/understanding-free-queries/",
            "text": "Understanding Free Monad Queries\n\n\nMost of the time Halogen queries look like this:\n\n\n1\n2\n3\n4\ndata\n \nQueryF\n \n(\n\u2026\n \nother\n \ntype\n \narguments\n \nomitted\n \n\u2026\n)\n \na\n\n  \n=\n \n...\n\n  \n|\n \nSetVisibility\n \nVisibility\n \na\n\n  \n|\n \nGetVisibility\n \n(\nVisibility\n \n-\n \na\n)\n\n\n\n\n\n\n\n(where \nQueryF\n is used directly as the Halogen query functor)\n\n\nThis library takes a slightly different approach: the query functor is actually \nControl\n.\nMonad\n.\nFree\n.\nFree\n \nQueryF\n, the \nfree monad\n generated by the query functor.\n\n\nThis allows queries the full power of monadic (and applicative) composition: sequencing effects, determining control flow based on previous results, and my favorite: doing nothing (\npure\n \nunit\n).\n\n\nWe now define smart query constructors for this Free pattern like so:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n-- | Set the container visibility (`On` or `Off`).\n\n\nsetVisibility\n \n::\n \n\u2200\n \no\n \nitem\n \neff\n.\n \nVisibility\n \n-\n \nQuery\n \no\n \nitem\n \neff\n \nUnit\n\n\nsetVisibility\n \nv\n \n=\n \nliftF\n \n(\nSetVisibility\n \nv\n \nunit\n)\n\n\n\n-- | Get the container visibility (`On` or `Off`). Most useful when sequenced\n\n\n-- | with other actions.\n\n\ngetVisibility\n \n::\n \n\u2200\n \no\n \nitem\n \neff\n.\n \nQuery\n \no\n \nitem\n \neff\n \nVisibility\n\n\ngetVisibility\n \n=\n \nliftF\n \n(\nGetVisibility\n \nid\n)\n\n\n\n\n\n\n\nDifferent patterns\n\n\nIn the simple cases, the helpers Halogen use to work with raw query constructors are folded into the smart Free query constructors already: \nH\n.\naction\n \n(\nSetVisibility\n \nOn\n)\n becomes simply \nsetVisiblity\n \nOn\n, and similarly \nH\n.\nrequest\n \nGetVisibility\n is just \ngetVisibility\n. This is because these patterns are typically present already smart constructors: \nsetVisibility\n returns \nFree\n \nQueryF\n \nUnit\n, since it is an action, and \ngetVisibility\n returns \nFree\n \nQueryF\n \nVisibility\n, since it requests the visibility. This allows for easy composition in \ndo\n notation:\n\n\n1\n2\n3\ntoggleVisibility\n \n=\n \ndo\n\n  \nvis\n \n-\n \ngetVisibility\n\n  \nsetVisibility\n \n(\nnot\n \nvis\n)\n\n\n\n\n\n\n\nC\u2019est tr\u00e8s facile!\n\n\nEvent handlers look a little different. This is one example:\n\n\n1\n2\n3\n4\nHE\n.\nonMouseDown\n \n\\\nev\n \n-\n \nJust\n \ndo\n\n    \nSelect\n.\npreventClick\n \nev\n\n    \nSelect\n.\nselect\n \nindex\n\n    \nwhen\n \ndoBlur\n \nSelect\n.\ntriggerBlur\n\n\n\n\n\n\n\n(Of course you may return \nNothing\n if you so wish, but its effect is just like \npure\n \nunit\n now.)\n\n\nIf you do not need access to the argument \nev\n, \nSelect\n.\nalways\n provides a simple shortcut for \nconst\n \n \nJust\n:\n\n\n1\nHE\n.\nonMouseOver\n \n$\n \nSelect\n.\nalways\n \n$\n \nSelect\n.\nhighlight\n \n(\nIndex\n \nindex\n)\n\n\n\n\n\n\n\nReturning non-unit values\n\n\nUse \nmap\n or \n$\n or \npure\n to return other types of values from a query. So, instead of something like this:\n\n\n1\n2\nH\n.\nsubscribe\n \n$\n \neventSource\n \nsomeEventSource\n\n  \n\\\nvalue\n \n-\n \nJust\n \n(\nSetVisibility\n \nvalue\n \nH\n.\nListening\n)\n\n\n\n\n\n\n\nUse\n\n\n1\n2\nH\n.\nsubscribe\n \n$\n \neventSource\n \nsomeEventSource\n\n  \n\\\nvalue\n \n-\n \nJust\n \n$\n \nsetVisibility\n \nvalue\n \n$\n \nH\n.\nListening\n\n\n\n\n\n\n\nor\n\n\n1\n2\n3\n4\nH\n.\nsubscribe\n \n$\n \neventSource\n \nsomeEventSource\n\n  \n\\\nvalue\n \n-\n \nJust\n \ndo\n\n    \nsetVisibility\n \nvalue\n\n    \npure\n \nH\n.\nListening\n\n\n\n\n\n\n\n\n\nMany thanks to \nNicholas Scheel\n for providing the implementation of \nQueryF\n and the documentation above.",
            "title": "Understanding free queries"
        },
        {
            "location": "/concepts/understanding-free-queries/#understanding-free-monad-queries",
            "text": "Most of the time Halogen queries look like this:  1\n2\n3\n4 data   QueryF   ( \u2026   other   type   arguments   omitted   \u2026 )   a \n   =   ... \n   |   SetVisibility   Visibility   a \n   |   GetVisibility   ( Visibility   -   a )    (where  QueryF  is used directly as the Halogen query functor)  This library takes a slightly different approach: the query functor is actually  Control . Monad . Free . Free   QueryF , the  free monad  generated by the query functor.  This allows queries the full power of monadic (and applicative) composition: sequencing effects, determining control flow based on previous results, and my favorite: doing nothing ( pure   unit ).  We now define smart query constructors for this Free pattern like so:  1\n2\n3\n4\n5\n6\n7\n8 -- | Set the container visibility (`On` or `Off`).  setVisibility   ::   \u2200   o   item   eff .   Visibility   -   Query   o   item   eff   Unit  setVisibility   v   =   liftF   ( SetVisibility   v   unit )  -- | Get the container visibility (`On` or `Off`). Most useful when sequenced  -- | with other actions.  getVisibility   ::   \u2200   o   item   eff .   Query   o   item   eff   Visibility  getVisibility   =   liftF   ( GetVisibility   id )",
            "title": "Understanding Free Monad Queries"
        },
        {
            "location": "/concepts/understanding-free-queries/#different-patterns",
            "text": "In the simple cases, the helpers Halogen use to work with raw query constructors are folded into the smart Free query constructors already:  H . action   ( SetVisibility   On )  becomes simply  setVisiblity   On , and similarly  H . request   GetVisibility  is just  getVisibility . This is because these patterns are typically present already smart constructors:  setVisibility  returns  Free   QueryF   Unit , since it is an action, and  getVisibility  returns  Free   QueryF   Visibility , since it requests the visibility. This allows for easy composition in  do  notation:  1\n2\n3 toggleVisibility   =   do \n   vis   -   getVisibility \n   setVisibility   ( not   vis )    C\u2019est tr\u00e8s facile!  Event handlers look a little different. This is one example:  1\n2\n3\n4 HE . onMouseDown   \\ ev   -   Just   do \n     Select . preventClick   ev \n     Select . select   index \n     when   doBlur   Select . triggerBlur    (Of course you may return  Nothing  if you so wish, but its effect is just like  pure   unit  now.)  If you do not need access to the argument  ev ,  Select . always  provides a simple shortcut for  const     Just :  1 HE . onMouseOver   $   Select . always   $   Select . highlight   ( Index   index )",
            "title": "Different patterns"
        },
        {
            "location": "/concepts/understanding-free-queries/#returning-non-unit-values",
            "text": "Use  map  or  $  or  pure  to return other types of values from a query. So, instead of something like this:  1\n2 H . subscribe   $   eventSource   someEventSource \n   \\ value   -   Just   ( SetVisibility   value   H . Listening )    Use  1\n2 H . subscribe   $   eventSource   someEventSource \n   \\ value   -   Just   $   setVisibility   value   $   H . Listening    or  1\n2\n3\n4 H . subscribe   $   eventSource   someEventSource \n   \\ value   -   Just   do \n     setVisibility   value \n     pure   H . Listening     Many thanks to  Nicholas Scheel  for providing the implementation of  QueryF  and the documentation above.",
            "title": "Returning non-unit values"
        },
        {
            "location": "/examples/",
            "text": "Examples\n\n\nYou can play around with a few example components here. However, for a much richer set of components with much more functionality, check out the \nOcelot design system by CitizenNet\n.\n\n\nDropdown\n\n\nDropdowns are a common button-driven input type, especially for navigation. But most custom dropdowns sacrifice usability: unlike browser default dropdowns, you can't type on most custom dropdowns, nor are many built with accessibility in mind. With \nSelect\n you can easily create rich, usable dropdowns with little code.\n\n\n\n\n\nCurious how to build a dropdown with \nSelect\n? Check out \nthe dropdown tutorial\n.\n\n\nTypeahead / Autocomplete\n\n\nThis library was originally designed so that we could build typeaheads with all sorts of custom rendering and functionality. It was frustrating to find solutions that almost worked, but broke down as soon as you needed a moderate level of customization.\n\n\nBuilding typeaheads with \nSelect\n is only a little more complex than building dropdowns. Instead of a button as input, you'll use a text input, and you'll be responsible for deciding how to handle user searches. \nSelect\n handles debouncing user input, keyboard navigation, and more on your behalf.\n\n\nThe typeahead below is quite simple; to see examples of more sophisticated typeaheads -- including ones that fetch and display data asynchronously -- check out the \nOcelot component library\n.\n\n\n\n\n\nCurious how to build a typeahead with \nSelect\n? Check out \nthe typeahead tutorial\n.",
            "title": "Examples"
        },
        {
            "location": "/examples/#examples",
            "text": "You can play around with a few example components here. However, for a much richer set of components with much more functionality, check out the  Ocelot design system by CitizenNet .",
            "title": "Examples"
        },
        {
            "location": "/examples/#dropdown",
            "text": "Dropdowns are a common button-driven input type, especially for navigation. But most custom dropdowns sacrifice usability: unlike browser default dropdowns, you can't type on most custom dropdowns, nor are many built with accessibility in mind. With  Select  you can easily create rich, usable dropdowns with little code.   Curious how to build a dropdown with  Select ? Check out  the dropdown tutorial .",
            "title": "Dropdown"
        },
        {
            "location": "/examples/#typeahead-autocomplete",
            "text": "This library was originally designed so that we could build typeaheads with all sorts of custom rendering and functionality. It was frustrating to find solutions that almost worked, but broke down as soon as you needed a moderate level of customization.  Building typeaheads with  Select  is only a little more complex than building dropdowns. Instead of a button as input, you'll use a text input, and you'll be responsible for deciding how to handle user searches.  Select  handles debouncing user input, keyboard navigation, and more on your behalf.  The typeahead below is quite simple; to see examples of more sophisticated typeaheads -- including ones that fetch and display data asynchronously -- check out the  Ocelot component library .   Curious how to build a typeahead with  Select ? Check out  the typeahead tutorial .",
            "title": "Typeahead / Autocomplete"
        }
    ]
}