{
    "docs": [
        {
            "location": "/",
            "text": "Welcome\n\u00b6\n\n\nSelect\n helps you build selection user interfaces in PureScript with Halogen. You can use it to build dropdowns, typeaheads and autocompletes, date pickers, image pickers, and more, with features like keyboard navigation, accessibility, and state management handled for you. This library takes a unique approach to component design to ensure you can leverage its features without compromising your design in any way.\n\n\nInstallation\n\u00b6\n\n\nYou can use \nSelect\n in your PureScript project with a compatible package manager. The PureScript community typically leverages \npsc-package\n or Bower:\n\n\n1\n2\n3\n4\n5\n# Using psc-package\n\n$ psc-package install halogen-select\n\n\n# Using Bower\n\n$ bower install --save purescript-halogen-select\n\n\n\n\n\n\nQuick Start\n\u00b6\n\n\nIf this is your first time using \nSelect\n, start with the \ntutorials\n. I'd recommend starting with the simplest example where you'll learn to make this dropdown component:\n\n\n\n\n\n\n\nTip\n\n\nDon't want to build your own UI components? Check out the \nOcelot component library\n!\n\n\n\n\nIf this isn't your first time, you'll find value in these resources:\n\n\n\n\nThe \nhow-to\n section contains plenty of short guides for common tasks you'll perform using \nSelect\n. Consider it a grab-bag of useful strategies and examples you can refer to when developing new components.\n\n\nThe \nconcepts\n section contains more detailed explanations on the design of the library. It will help you understand how to make good design choices and make the most of the tools available to you.\n\n\nThe \nreference documentation on Pursuit\n contains the module documentation and source code. It's a useful reference to verify what functions are available to you.\n\n\nThe \nexamples folder on Github\n contains the working source code for all the components in the \ntutorials\n. If you're building a similar component, this code can help you get started.\n\n\n\n\nWhy Select?\n\u00b6\n\n\nSelect\n provides essential behaviors for selection UI as a flexible, extensible Halogen component. But you won't find a single render function in the code. Instead, with a few helper functions, you can write your own \nState\n \n->\n \nHTML\n function however you'd like. You can:\n\n\n\n\nExtend the component's functionality by embedding new queries in the HTML\n\n\nExtend the component's data by including as much additional state from the parent as you want (which you can then use in your render function)\n\n\nLeverage the provided features for user interaction, state management, accessibility, and logic\n\n\nRetain complete freedom over the design and aesthetic of your selection component\n\n\n\n\n\n\nFor visual learners\n\n\nI gave a talk at the Los Angeles PureScript meetup in April 2018 about the approach this library takes. It provides an overview of our design approach, including advantages and drawbacks, as well as a simple walkthrough of building a dropdown. No, the man in the preview isn't me -- that's \nPhil Freeman\n, the designer of the PureScript programming language.",
            "title": "Home"
        },
        {
            "location": "/#welcome",
            "text": "Select  helps you build selection user interfaces in PureScript with Halogen. You can use it to build dropdowns, typeaheads and autocompletes, date pickers, image pickers, and more, with features like keyboard navigation, accessibility, and state management handled for you. This library takes a unique approach to component design to ensure you can leverage its features without compromising your design in any way.",
            "title": "Welcome"
        },
        {
            "location": "/#installation",
            "text": "You can use  Select  in your PureScript project with a compatible package manager. The PureScript community typically leverages  psc-package  or Bower:  1\n2\n3\n4\n5 # Using psc-package \n$ psc-package install halogen-select # Using Bower \n$ bower install --save purescript-halogen-select",
            "title": "Installation"
        },
        {
            "location": "/#quick-start",
            "text": "If this is your first time using  Select , start with the  tutorials . I'd recommend starting with the simplest example where you'll learn to make this dropdown component:    Tip  Don't want to build your own UI components? Check out the  Ocelot component library !   If this isn't your first time, you'll find value in these resources:   The  how-to  section contains plenty of short guides for common tasks you'll perform using  Select . Consider it a grab-bag of useful strategies and examples you can refer to when developing new components.  The  concepts  section contains more detailed explanations on the design of the library. It will help you understand how to make good design choices and make the most of the tools available to you.  The  reference documentation on Pursuit  contains the module documentation and source code. It's a useful reference to verify what functions are available to you.  The  examples folder on Github  contains the working source code for all the components in the  tutorials . If you're building a similar component, this code can help you get started.",
            "title": "Quick Start"
        },
        {
            "location": "/#why-select",
            "text": "Select  provides essential behaviors for selection UI as a flexible, extensible Halogen component. But you won't find a single render function in the code. Instead, with a few helper functions, you can write your own  State   ->   HTML  function however you'd like. You can:   Extend the component's functionality by embedding new queries in the HTML  Extend the component's data by including as much additional state from the parent as you want (which you can then use in your render function)  Leverage the provided features for user interaction, state management, accessibility, and logic  Retain complete freedom over the design and aesthetic of your selection component    For visual learners  I gave a talk at the Los Angeles PureScript meetup in April 2018 about the approach this library takes. It provides an overview of our design approach, including advantages and drawbacks, as well as a simple walkthrough of building a dropdown. No, the man in the preview isn't me -- that's  Phil Freeman , the designer of the PureScript programming language.",
            "title": "Why Select?"
        },
        {
            "location": "/tutorials/dropdown/",
            "text": "Let's Build a Dropdown\n\u00b6",
            "title": "Build a dropdown"
        },
        {
            "location": "/tutorials/dropdown/#lets-build-a-dropdown",
            "text": "",
            "title": "Let's Build a Dropdown"
        },
        {
            "location": "/how-to/embed-parent-queries/",
            "text": "How to Embed Parent Queries\n\u00b6\n\n\nOne of the most powerful ways to extend \nSelect\n is to write functionality in your component, triggered by a query, and then embed that query into the \nSelect\n component.",
            "title": "How to embed parent queries"
        },
        {
            "location": "/how-to/embed-parent-queries/#how-to-embed-parent-queries",
            "text": "One of the most powerful ways to extend  Select  is to write functionality in your component, triggered by a query, and then embed that query into the  Select  component.",
            "title": "How to Embed Parent Queries"
        },
        {
            "location": "/concepts/understanding-free-queries/",
            "text": "Understanding Free Monad Queries\n\u00b6\n\n\nMost of the time Halogen queries look like this:\n\n\n1\n2\n3\n4\ndata\n \nQueryF\n \n(\n\u2026\n \nother\n \ntype\n \narguments\n \nomitted\n \n\u2026\n)\n \na\n\n  \n=\n \n...\n\n  \n|\n \nSetVisibility\n \nVisibility\n \na\n\n  \n|\n \nGetVisibility\n \n(\nVisibility\n \n->\n \na\n)\n\n\n\n\n\n\n\n(where \nQueryF\n is used directly as the Halogen query functor)\n\n\nThis library takes a slightly different approach: the query functor is actually \nControl\n.\nMonad\n.\nFree\n.\nFree\n \nQueryF\n, the \nfree monad\n generated by the query functor.\n\n\nThis allows queries the full power of monadic (and applicative) composition: sequencing effects, determining control flow based on previous results, and my favorite: doing nothing (\npure\n \nunit\n).\n\n\nWe now define smart query constructors for this Free pattern like so:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n-- | Set the container visibility (`On` or `Off`).\n\n\nsetVisibility\n \n::\n \n\u2200\n \no\n \nitem\n \neff\n.\n \nVisibility\n \n->\n \nQuery\n \no\n \nitem\n \neff\n \nUnit\n\n\nsetVisibility\n \nv\n \n=\n \nliftF\n \n(\nSetVisibility\n \nv\n \nunit\n)\n\n\n\n-- | Get the container visibility (`On` or `Off`). Most useful when sequenced\n\n\n-- | with other actions.\n\n\ngetVisibility\n \n::\n \n\u2200\n \no\n \nitem\n \neff\n.\n \nQuery\n \no\n \nitem\n \neff\n \nVisibility\n\n\ngetVisibility\n \n=\n \nliftF\n \n(\nGetVisibility\n \nid\n)\n\n\n\n\n\n\n\nDifferent patterns\n\u00b6\n\n\nIn the simple cases, the helpers Halogen use to work with raw query constructors are folded into the smart Free query constructors already: \nH\n.\naction\n \n(\nSetVisibility\n \nOn\n)\n becomes simply \nsetVisiblity\n \nOn\n, and similarly \nH\n.\nrequest\n \nGetVisibility\n is just \ngetVisibility\n. This is because these patterns are typically present already smart constructors: \nsetVisibility\n returns \nFree\n \nQueryF\n \nUnit\n, since it is an action, and \ngetVisibility\n returns \nFree\n \nQueryF\n \nVisibility\n, since it requests the visibility. This allows for easy composition in \ndo\n notation:\n\n\n1\n2\n3\ntoggleVisibility\n \n=\n \ndo\n\n  \nvis\n \n<-\n \ngetVisibility\n\n  \nsetVisibility\n \n(\nnot\n \nvis\n)\n\n\n\n\n\n\n\nC\u2019est tr\u00e8s facile!\n\n\nEvent handlers look a little different. This is one example:\n\n\n1\n2\n3\n4\nHE\n.\nonMouseDown\n \n\\\nev\n \n->\n \nJust\n \ndo\n\n    \nSelect\n.\npreventClick\n \nev\n\n    \nSelect\n.\nselect\n \nindex\n\n    \nwhen\n \ndoBlur\n \nSelect\n.\ntriggerBlur\n\n\n\n\n\n\n\n(Of course you may return \nNothing\n if you so wish, but its effect is just like \npure\n \nunit\n now.)\n\n\nIf you do not need access to the argument \nev\n, \nSelect\n.\nalways\n provides a simple shortcut for \nconst\n \n<<<\n \nJust\n:\n\n\n1\nHE\n.\nonMouseOver\n \n$\n \nSelect\n.\nalways\n \n$\n \nSelect\n.\nhighlight\n \n(\nIndex\n \nindex\n)\n\n\n\n\n\n\n\nReturning non-unit values\n\u00b6\n\n\nUse \nmap\n or \n<$\n or \npure\n to return other types of values from a query. So, instead of something like this:\n\n\n1\n2\nH\n.\nsubscribe\n \n$\n \neventSource'\n \nsomeEventSource\n\n  \n\\\nvalue\n \n->\n \nJust\n \n(\nSetVisibility\n \nvalue\n \nH\n.\nListening\n)\n\n\n\n\n\n\n\nUse\n\n\n1\n2\nH\n.\nsubscribe\n \n$\n \neventSource'\n \nsomeEventSource\n\n  \n\\\nvalue\n \n->\n \nJust\n \n$\n \nsetVisibility\n \nvalue\n \n$>\n \nH\n.\nListening\n\n\n\n\n\n\n\nor\n\n\n1\n2\n3\n4\nH\n.\nsubscribe\n \n$\n \neventSource'\n \nsomeEventSource\n\n  \n\\\nvalue\n \n->\n \nJust\n \ndo\n\n    \nsetVisibility\n \nvalue\n\n    \npure\n \nH\n.\nListening\n\n\n\n\n\n\n\n\n\nMany thanks to \nNicholas Scheel\n for providing the implementation of \nQueryF\n and the documentation above.",
            "title": "Understanding free queries"
        },
        {
            "location": "/concepts/understanding-free-queries/#understanding-free-monad-queries",
            "text": "Most of the time Halogen queries look like this:  1\n2\n3\n4 data   QueryF   ( \u2026   other   type   arguments   omitted   \u2026 )   a \n   =   ... \n   |   SetVisibility   Visibility   a \n   |   GetVisibility   ( Visibility   ->   a )    (where  QueryF  is used directly as the Halogen query functor)  This library takes a slightly different approach: the query functor is actually  Control . Monad . Free . Free   QueryF , the  free monad  generated by the query functor.  This allows queries the full power of monadic (and applicative) composition: sequencing effects, determining control flow based on previous results, and my favorite: doing nothing ( pure   unit ).  We now define smart query constructors for this Free pattern like so:  1\n2\n3\n4\n5\n6\n7\n8 -- | Set the container visibility (`On` or `Off`).  setVisibility   ::   \u2200   o   item   eff .   Visibility   ->   Query   o   item   eff   Unit  setVisibility   v   =   liftF   ( SetVisibility   v   unit )  -- | Get the container visibility (`On` or `Off`). Most useful when sequenced  -- | with other actions.  getVisibility   ::   \u2200   o   item   eff .   Query   o   item   eff   Visibility  getVisibility   =   liftF   ( GetVisibility   id )",
            "title": "Understanding Free Monad Queries"
        },
        {
            "location": "/concepts/understanding-free-queries/#different-patterns",
            "text": "In the simple cases, the helpers Halogen use to work with raw query constructors are folded into the smart Free query constructors already:  H . action   ( SetVisibility   On )  becomes simply  setVisiblity   On , and similarly  H . request   GetVisibility  is just  getVisibility . This is because these patterns are typically present already smart constructors:  setVisibility  returns  Free   QueryF   Unit , since it is an action, and  getVisibility  returns  Free   QueryF   Visibility , since it requests the visibility. This allows for easy composition in  do  notation:  1\n2\n3 toggleVisibility   =   do \n   vis   <-   getVisibility \n   setVisibility   ( not   vis )    C\u2019est tr\u00e8s facile!  Event handlers look a little different. This is one example:  1\n2\n3\n4 HE . onMouseDown   \\ ev   ->   Just   do \n     Select . preventClick   ev \n     Select . select   index \n     when   doBlur   Select . triggerBlur    (Of course you may return  Nothing  if you so wish, but its effect is just like  pure   unit  now.)  If you do not need access to the argument  ev ,  Select . always  provides a simple shortcut for  const   <<<   Just :  1 HE . onMouseOver   $   Select . always   $   Select . highlight   ( Index   index )",
            "title": "Different patterns"
        },
        {
            "location": "/concepts/understanding-free-queries/#returning-non-unit-values",
            "text": "Use  map  or  <$  or  pure  to return other types of values from a query. So, instead of something like this:  1\n2 H . subscribe   $   eventSource'   someEventSource \n   \\ value   ->   Just   ( SetVisibility   value   H . Listening )    Use  1\n2 H . subscribe   $   eventSource'   someEventSource \n   \\ value   ->   Just   $   setVisibility   value   $>   H . Listening    or  1\n2\n3\n4 H . subscribe   $   eventSource'   someEventSource \n   \\ value   ->   Just   do \n     setVisibility   value \n     pure   H . Listening     Many thanks to  Nicholas Scheel  for providing the implementation of  QueryF  and the documentation above.",
            "title": "Returning non-unit values"
        },
        {
            "location": "/examples/",
            "text": "Examples\n\u00b6\n\n\nYou can play around with a few example components here. However, for a much richer set of components with much more functionality, check out the \nOcelot design system by CitizenNet\n.\n\n\nDropdown\n\u00b6\n\n\nDropdowns are a common button-driven input type, especially for navigation. But most custom dropdowns sacrifice usability: unlike browser default dropdowns, you can't type on most custom dropdowns, nor are many built with accessibility in mind. With \nSelect\n you can easily create rich, usable dropdowns with little code.\n\n\n\n\n\nCurious how to build a dropdown with \nSelect\n? Check out \nthe dropdown tutorial\n.\n\n\nTypeahead / Autocomplete\n\u00b6\n\n\nThis library was originally designed so that we could build typeaheads with all sorts of custom rendering and functionality. It was frustrating to find solutions that almost worked, but broke down as soon as you needed a moderate level of customization.\n\n\nBuilding typeaheads with \nSelect\n is only a little more complex than building dropdowns. Instead of a button as input, you'll use a text input, and you'll be responsible for deciding how to handle user searches. \nSelect\n handles debouncing user input, keyboard navigation, and more on your behalf.\n\n\nThe typeahead below is quite simple; to see examples of more sophisticated typeaheads -- including ones that fetch and display data asynchronously -- check out the \nOcelot component library\n.\n\n\n\n\n\nCurious how to build a typeahead with \nSelect\n? Check out \nthe typeahead tutorial\n.",
            "title": "Examples"
        },
        {
            "location": "/examples/#examples",
            "text": "You can play around with a few example components here. However, for a much richer set of components with much more functionality, check out the  Ocelot design system by CitizenNet .",
            "title": "Examples"
        },
        {
            "location": "/examples/#dropdown",
            "text": "Dropdowns are a common button-driven input type, especially for navigation. But most custom dropdowns sacrifice usability: unlike browser default dropdowns, you can't type on most custom dropdowns, nor are many built with accessibility in mind. With  Select  you can easily create rich, usable dropdowns with little code.   Curious how to build a dropdown with  Select ? Check out  the dropdown tutorial .",
            "title": "Dropdown"
        },
        {
            "location": "/examples/#typeahead-autocomplete",
            "text": "This library was originally designed so that we could build typeaheads with all sorts of custom rendering and functionality. It was frustrating to find solutions that almost worked, but broke down as soon as you needed a moderate level of customization.  Building typeaheads with  Select  is only a little more complex than building dropdowns. Instead of a button as input, you'll use a text input, and you'll be responsible for deciding how to handle user searches.  Select  handles debouncing user input, keyboard navigation, and more on your behalf.  The typeahead below is quite simple; to see examples of more sophisticated typeaheads -- including ones that fetch and display data asynchronously -- check out the  Ocelot component library .   Curious how to build a typeahead with  Select ? Check out  the typeahead tutorial .",
            "title": "Typeahead / Autocomplete"
        }
    ]
}